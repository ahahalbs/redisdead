<html>
    <head>
        <title>grail</title>
        <script src="enable-threads.js"></script>
        <script src="aframe-master.min.js"></script>
        <script crossorigin src="maxiInstruments.v.0.7.1.js"></script>
        <script src="bassOK.js"></script>
        <script>
            let animationStarted = false;
            let bassSynth;
            let sampler; 

            // make clear that the origin is on mimicproject
            var origin = "https://mimicproject.com/libs";
            // pass the origin in when loading your instruments
            const instruments = new MaxiInstruments(origin);
            const loadSound=()=>{
                instruments.loadModules().then(()=> {

                    bassSynth = instruments.addSynth();
                    bassSynth.setOsc(2);

                    bassSynth.setParams([
                        ["oscFn",3],
                        ["lfoOscFn",0],
                        ["gain",0.5],
                        ["pan",0.5],
                        ["attack",375],
                        ["decay",1500],
                        ["sustain",1],
                        ["release",1245],
                        ["lfoFrequency",10],
                        ["lfoPitchMod",0],
                        ["lfoFilterMod",720],
                        ["lfoAmpMod",0.36],
                        ["adsrPitchMod",0],
                        ["cutoff",2644.8],
                        ["reverbMix",0.06],
                        ["roomSize",0],
                        ["delay",14994.000000000002],
                        ["delayMix",0.09],
                        ["frequency",440],
                        ["frequency2",440],
                    ]);

                    sampler = instruments.addSampler();
                    sampler.loadSample("aversion1.mp3", 0);
                    sampler.loadSample("fail2.mp3", 1);
                    sampler.setParam("rate_0", 1);
                    sampler.setParam("pan_0", 0.5);
                    sampler.setParam("gain_0", 1);
                    sampler.setParam("rate_1", 1);
                    sampler.setParam("pan_1", 0.5);
                    sampler.setParam("gain_1", 0.5);

                    let drums = [
                        {p:0, s:0, v:127}, 
                    ];
                    instruments.playPause();
                    sampler.setSequence(drums,4);

                }).catch((err)=> {
                    console.log("error", err);
                });
            };

            const playSomething=()=>{
                instruments.rewind();
                instruments.playPause();
                instruments.setTempo(129);
            }
        </script>
        <script>
            AFRAME.registerComponent('controller-listener', {
                init: function () {

                    // cylinder parent
                    this.container = document.createElement('a-entity');
                    this.el.sceneEl.appendChild(this.container);
                    this.el.setAttribute('raycaster', 'showLine', false);

                    // cylinder
                    this.cylinder = document.createElement('a-cylinder');
                    this.cylinder.setAttribute('radius', '0.005');  // Cylinder radius
                    const color = this.el.id === 'leftHand' ? '#FD3A69' : '#FECD1A';
                    this.cylinder.setAttribute('material', {color: color, transparent: true, opacity: 0.5});
                    this.cylinder.setAttribute('rotation', {x: 90, y: 0, z: 0});

                    // add to parent
                    this.container.appendChild(this.cylinder);

                    //trigger state
                    this.triggerdown = false;

                    this.el.addEventListener('buttondown', (event) => {
                        const tilesEntity = document.getElementById('tilesEntity');

                        if (!animationStarted) {
                            tilesEntity.setAttribute('animation', 'property: position; from:0 0 0; to: 0 0 2480; dur: 288377; easing: linear');
                            loadSound();  
                            playSomething();
                            animationStarted = true;
                        }
                    });
                    //start the step sequencer
                    document.addEventListener('keydown', (event) => {
                        if (event.key == 'p' && animationStarted == false){
                            tilesEntity.setAttribute('animation', 'property: position; from:0 0 0; to: 0 0 2480; dur: 288377; easing: linear');
                            //loadSound();  
                            playSomething();
                            animationStarted = true;
                        }
                    });
                    this.el.addEventListener('triggerdown', (event) => {
                        this.cylinder.setAttribute('material', {color: color, transparent: false, opacity: 1});
                        this.triggerdown = true;
                        const intersectedEls = this.el.components.raycaster.intersectedEls;

                        if (intersectedEls.length > 0) {

                            let noteValue = intersectedEls[0].dataset.basslineP;
                            let noteLength = intersectedEls[0].dataset.basslineL * 116;

                            if (intersectedEls[0].getAttribute('id') === 'bassLeft' && this.el.id === 'leftHand') {
                                bassSynth.noteon(noteValue);
                                intersectedEls[0].setAttribute("visible", 'false');
                                this.triggerdown = false;
                            } else if (intersectedEls[0].getAttribute('id') === 'bassRight' && this.el.id === 'rightHand') {
                                bassSynth.noteon(noteValue);
                                intersectedEls[0].setAttribute("visible", 'false');
                                this.triggerdown = false;
                            }

                            setTimeout(() => {
                                bassSynth.noteoff(noteValue);
                            }, noteLength);
                        }  

                        setTimeout(() => {
                            this.cylinder.setAttribute('material', {color: color, transparent: true, opacity: 0.25});
                        }, 250);
                    });
                    // wait for the raycaster component to be loaded before update
                    this.el.addEventListener('loaded', () => {
                        this.updateCylinder();
                    });
                    // hide ray line
                    this.el.setAttribute('raycaster', 'showLine', false);
                },
                tick: function () {
                    // update the cylinder
                    this.updateCylinder();
                },
                updateCylinder: function () {
                    const raycasterComponent = this.el.components.raycaster;
                    if (raycasterComponent) {
                        const origin = raycasterComponent.raycaster.ray.origin;
                        const direction = raycasterComponent.raycaster.ray.direction.clone();
                        const far = raycasterComponent.data.far;

                        // match cylinder's height to raycaster's far 
                        this.cylinder.setAttribute('height', far);

                        // calculate the offset position
                        const offsetPosition = new THREE.Vector3().copy(direction).multiplyScalar(far / 2);

                        // match cylinders parent to raycaster's origin and adjust for offset
                        this.container.object3D.position.copy(origin).add(offsetPosition);

                        // Set rotation to match the ray direction
                        this.container.object3D.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), direction);
                    }
                }
            });
        </script>
        <script>
            AFRAME.registerComponent('checker', {
                init: function () {
                    this.death = this.el;
                    this.hitCount = 0.02;
                    this.currentOpac = this.hitCount;
                    this.targetOpac = this.hitCount;
                    this.tilesCrossed = {};
                    this.death.setAttribute('animation', {
                        property: 'material.opacity',
                        dur: 464, 
                        dir: 'alternate',
                        easing: 'linear',
                        loop: true,
                        from: 0,
                        to: this.currentOpac
                    });
                },
                tick: function () {
                    const tilesEntity = document.querySelector('#tilesEntity');
                    const tiles = tilesEntity.children;

                    for (let i = 0; i < tiles.length; i++) {
                        let tilePositionZ = tiles[i].getAttribute('position').z + tilesEntity.getAttribute('position').z;
                        let tileDepth = tiles[i].getAttribute('depth') /2; 
                        let tileVis = tiles[i].getAttribute('visible');
                        if (tilePositionZ+tileDepth >= 0 && !this.tilesCrossed[i] && tileVis == true) {
                            this.tilesCrossed[i] = true;
                            this.hitCount += 0.02;
                            this.targetOpac = Math.min(this.hitCount, 1.0);
                            document.querySelector('#hitPlane').emit('hit');
                        } 
                    }

                    if (this.hitCount > 1.0) {
                        this.death.removeAttribute('animation');
                        this.death.setAttribute('material', 'opacity', 1);
                        document.querySelector('#hitPlane').emit('hit');
                        this.el.sceneEl.emit('stop');
                    }

                    const currentOpacity = parseFloat(this.death.getAttribute('material').opacity);
                    if (currentOpacity <= 0) {
                        if (this.currentOpac !== this.targetOpac) {
                            this.currentOpac = this.targetOpac;
                            this.death.setAttribute('animation', 'to', this.currentOpac);
                        }
                        this.death.setAttribute('animation', 'dur', 464);
                    }
                }
            });
        </script>
        <script>
            AFRAME.registerComponent('hit-animator', {
                init: function () {
                    //listen for hit
                    this.el.addEventListener('hit', () => {
                        // Stop any previous animation and remove it
                        this.el.removeAttribute('animation');

                        //set animation
                        this.el.setAttribute('animation', {
                            property: 'material.opacity',
                            dur: 116,
                            easing: 'linear',
                            loop: false,
                            from: 0,
                            to: 0.5
                        });
                    });

                    // reset opacity
                    this.el.addEventListener('animationcomplete', () => {
                        this.el.setAttribute('material', 'opacity', 0);
                    });
                }
            });
        </script>
        <script>
            AFRAME.registerComponent('helper', {
                schema: {
                    threshold: {type: 'number', default: -7},
                    axis: {type: 'string', default: 'z'}  // Default to only consider z axis, if 'xz' then consider both x and z axis
                },

                init: function () {
                    this.helper = this.el;
                    this.tilesCrossed = {};
                    this.helper.setAttribute('animation', {
                        property: 'material.opacity',
                        dur: 464, 
                        easing: 'easeInSine',
                        loop: false,
                        from: 0.01,
                        to: 1,
                        autoplay: false
                    });

                    // Listen for the animationcomplete event
                    this.helper.addEventListener('animationcomplete', () => {
                        // When the animation finishes, set the opacity back to 0
                        this.helper.setAttribute('material', 'opacity', 0.1);
                    });
                },

                tick: function () {
                    const tilesEntity = document.querySelector('#tilesEntity');
                    const tiles = tilesEntity.children;
                    const helperX = this.helper.getAttribute('position').x;
                    const helperWidth = this.helper.getAttribute('width');
                    const helperMinX = helperX - helperWidth / 2;
                    const helperMaxX = helperX + helperWidth / 2;

                    for (let i = 0; i < tiles.length; i++) {
                        let tilePositionZ = tiles[i].getAttribute('position').z + tilesEntity.getAttribute('position').z;
                        let tilePositionX = tiles[i].getAttribute('position').x + tilesEntity.getAttribute('position').x;
                        let tileDepth = tiles[i].getAttribute('depth') /2; 
                        let tileVis = tiles[i].getAttribute('visible');
                        if (this.data.axis === 'xz') {
                            if (tilePositionZ + tileDepth >= this.data.threshold && tilePositionX >= helperMinX && tilePositionX <= helperMaxX && !this.tilesCrossed[i] && tileVis == true) {
                                this.tilesCrossed[i] = true;
                                // Stop and then restart the animation
                                this.helper.setAttribute('animation', 'autoplay', false);
                                this.helper.setAttribute('animation', 'autoplay', true);
                            }
                        } else {
                            if (tilePositionZ + tileDepth >= this.data.threshold && !this.tilesCrossed[i] && tileVis == true) {
                                this.tilesCrossed[i] = true;
                                // Stop and then restart the animation
                                this.helper.setAttribute('animation', 'autoplay', false);
                                this.helper.setAttribute('animation', 'autoplay', true);
                            }
                        }
                    }
                }
            });
        </script>
        <script>
            window.addEventListener('DOMContentLoaded', (event) => {
                const sceneEl = document.querySelector('a-scene');
                const tilesEntity = document.getElementById('tilesEntity');
                const grail = document.getElementById('grail');

                function populateBlocks() {
                    for (let i = 0; i < bassline.length; i++) {
                        let tile = document.createElement('a-box');
                        tile.dataset.basslineP = bassline[i].p;
                        tile.dataset.basslineL = bassline[i].l;

                        if (i % 2 == 0) {
                            tile.setAttribute('material', 'color', '#FD3A69');
                            tile.setAttribute('id', 'bassLeft');
                            let x = -1;
                            let y = 0;
                            if (tile.dataset.basslineP == 53) {
                                x = -1;
                                y = 0;
                            } else if (tile.dataset.basslineP == 56) {
                                x = -2;
                                y = 1;
                            } else if (tile.dataset.basslineP == 57) {
                                x = -3;
                                y = 2;
                            } else if (tile.dataset.basslineP == 60) {
                                x = -4;
                                y = 3;
                            } else if (tile.dataset.basslineP == 62) {
                                x = -2;
                                y = 3;
                            } else if (tile.dataset.basslineP > 62) {
                                x = -1;
                                y = 2;
                            } else {
                                x = -1;
                                y = -1;
                            }
                            tile.setAttribute('position', { x: x, y: y, z: -bassline[i].s - (bassline[i].l / 2) - 8 });

                        } else {
                            tile.setAttribute('id', 'bassRight');
                            tile.setAttribute('material', 'color', '#FECD1A');
                            let x = 1;
                            let y = 0;
                            if (tile.dataset.basslineP == 53) {
                                x = 1;
                                y = 0;
                            } else if (tile.dataset.basslineP == 56) {
                                x = 2;
                                y = 1;
                            } else if (tile.dataset.basslineP == 57) {
                                x = 3;
                                y = 2;
                            } else if (tile.dataset.basslineP == 60) {
                                x = 4;
                                y = 3;
                            } else if (tile.dataset.basslineP == 62) {
                                x = 2;
                                y = 3;
                            } else if (tile.dataset.basslineP > 62) {
                                x = 1;
                                y = 2;
                            } else {
                                x = 1;
                                y = -1;
                            }
                            tile.setAttribute('position', { x: x, y: y, z: -bassline[i].s - (bassline[i].l / 2) - 8 });
                        }

                        tile.setAttribute('class', 'interactive');
                        tile.setAttribute('width', 0.75);
                        tile.setAttribute("height", 0.75);
                        tile.setAttribute("depth", tile.dataset.basslineL);
                        tile.setAttribute("visible", 'true');
                        tilesEntity.appendChild(tile);
                        
                    }
                    grail.setAttribute('position', {x: 0, y: 1, z: -2488});
                    grail.setAttribute('animation',"property: rotation; from: 20 0 20 ; to: 20 360 20; loop: true; dur: 5000; easing: linear");

                    tilesEntity.appendChild(grail);
                }

                if (sceneEl.hasLoaded) {
                    //grail.setAttribute('position', {x: 0, y: 1, z: 2480});
                    //tilesEntity.appendChild(grail);
                    //populateBlocks();
                    //sceneEl.appendChild(tilesEntity);
                } else {
                    sceneEl.addEventListener('loaded', () => {
                        populateBlocks();
                        sceneEl.appendChild(tilesEntity);
                        loadSound();
                    });
                }
            });
            document.addEventListener('hit', () => {
                sampler.noteon(1);               
            });

            //if death then stop
            document.addEventListener('stop', function () {
                const sceneEl = document.querySelector('a-scene');
                const tilesEntity = document.getElementById('tilesEntity');
                let help = document.getElementById('helper1');
                let help2 = document.getElementById('helper2');
                let help3 = document.getElementById('helper3');
                let help4 = document.getElementById('helper4');  
                let leftSpawn = document.getElementById('leftSpawn');  
                let rightSpawn = document.getElementById('rightSpawn');  
                help.setAttribute('visible', 'false');
                help2.setAttribute('visible', 'false');
                help3.setAttribute('visible', 'false');
                help4.setAttribute('visible', 'false');
                leftSpawn.setAttribute('visible', 'false');
                rightSpawn.setAttribute('visible', 'false');

                sampler.mute();
                instruments.playPause();

                while (tilesEntity.childNodes.length > 0) {
                    let childEntity = tilesEntity.childNodes[0];
                    tilesEntity.removeChild(childEntity);
                }
            });
        </script>
    </head>
    <body>
        <!--        <a-scene stats background="color: black" renderer="alpha: true; sortObjects:true; foveationLevel: 0">-->
        <a-scene stats background="color: black">
            <a-assets>
                <a-entity id="grail" gltf-model="./medieval_goblet/scene.gltf" scale="1 1 1" position="0 1 -8" rotation="20 90 20"  material="transparent: true; opacity: 0.5" layer="2" animation__spin="property: rotation; from: 20 0 20 ; to: 20 360 20; loop: true; dur: 5000; easing: linear"
></a-entity>
            </a-assets>

            <a-entity id="rig" position="0 0 0">   
                <a-entity id="leftHand" laser-controls="hand: left" raycaster="objects: .interactive; far: 10; showLine: false; lineOpacity: 0" controller-listener></a-entity>
                <a-entity id="rightHand" laser-controls="hand: right" raycaster="objects: .interactive; far: 10; showLine: false; lineOpacity: 0" controller-listener></a-entity>
                <a-box id="leftSpawn" color="#FD3A69" position="-1.5 0.5 -20" width="3" height="4" depth="1" side="double" opacity="0.05"helper="threshold: -24;axis: xz" ></a-box>
                <a-box id="rightSpawn" color="#FECD1A" position="1.5 0.5 -20" width="3" height="4" depth="1" side="double" opacity="0.05"helper="threshold: -24;axis: xz" ></a-box>

                <a-plane id='helper4' position="0 -1.51 -16" width="6" height="1" rotation="-90 0 0" material="color: white; transparent: true; opacity: 0.1" helper="threshold: -19"></a-plane>

                <a-plane id='helper3' position="0 -1.51 -12" width="6" height="1" rotation="-90 0 0" material="color: white; transparent: true; opacity: 0.1" helper="threshold: -15"></a-plane>

                <a-plane id='helper2' position="0 -1.51 -8" width="6" height="1" rotation="-90 0 0" material="color: white; transparent: true; opacity: 0.1" helper="threshold: -11"></a-plane>

                <a-plane id='helper1' position="0 -1.51 -4" width="6" height="1" rotation="-90 0 0" material="color: white; transparent: true; opacity: 0.1" helper="threshold: -7"></a-plane>

                <a-camera look-controls wasd-controls-enabled="true" far="24">

                  <a-plane id="face" position="0 0 -19.1" rotation="0 0 0" width="64" height="50" material="color: red; transparent: true; opacity: 0.0" checker animation="property: material.opacity; from: 0; to: 0; dur: 464; easing: easeInOutSine; dir: alternate; loop: true">

                        <a-plane id="hitPlane" position="0 0 -2" rotation="0 0 0" width="72" height="72" material="color: red; transparent: true; opacity: 0." hit-animator></a-plane>
                    </a-plane>
                </a-camera>
            </a-entity>

            <a-entity id="tilesEntity"></a-entity>
<!--

                    <a-entity gltf-model="./angel_statue/scene.gltf" scale="0.07 0.07 0.07" position="0 -1.5 -22" rotation="0 0 0" material="transparent: true; opacity: 0.5" layer="2"></a-entity>
                     
                    

        </a-scene>
    </body>
</html>