<html>
<head>
  <!-- must use the keyword 'crossorigin' when specifying src !! -->
 <script src="enable-threads.js"></script>
  <script crossorigin src = "maxiInstruments.v.0.7.2.js"></script>
  <script src="./dist/aframe-master.min.js"></script>
        <!--        CONTROLLER ABRIDGED NON-NONSENSE HACK OF LEE STEMKOSKIS-->
        <<!--        CONTROLLER ABRIDGED NON-NONSENSE HACK OF LEE STEMKOSKIS-->
        <script>AFRAME.registerComponent('controller', {
                schema: {
                    leftControllerId:  {type: 'string',  default: "#left-controller"},
                    rightControllerId: {type: 'string',  default: "#right-controller"},
                    moveSpeed: {type: 'number', default: 1.6},
                    smoothness: {type: 'number', default: 0.05}
                },
                init: function() {
                    this.leftController  = document.querySelector(this.data.leftControllerId);
                    this.rightController = document.querySelector(this.data.rightControllerId);

                    this.leftAxisX   = 0;
                    this.leftAxisY   = 0;

                    let self = this;

                    this.leftController.addEventListener('thumbstickmoved', function(event) {
                        self.leftAxisX = event.detail.x;
                        self.leftAxisY = event.detail.y;
                    });

                    // X button
                    this.el.addEventListener("xbuttondown", function(event) {
                        self.el.emit('xbuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener("xbuttonup", function(event) {
                        self.el.emit('xbuttonreleased', {pressed: false});
                    });

                    // Y button
                    this.el.addEventListener("ybuttondown", function(event) {
                        self.el.emit('ybuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener("ybuttonup", function(event) {
                        self.el.emit('ybuttonreleased', {pressed: false});
                    });

                    // A button
                    this.el.addEventListener("abuttondown", function(event) {
                        self.el.emit('abuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener("abuttonup", function(event) {
                        self.el.emit('abuttonreleased', {pressed: false});
                    });

                    // B button
                    this.el.addEventListener("bbuttondown", function(event) {
                        self.el.emit('bbuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener("bbuttonup", function(event) {
                        self.el.emit('bbuttonreleased', {pressed: false});
                    });

                    // Left trigger
                    this.el.addEventListener("triggerdown", function(event) {
                        self.el.emit('lefttriggerpressed', {pressed: true});
                    });

                    this.el.addEventListener("triggerup", function(event) {
                        self.el.emit('lefttriggerreleased', {pressed: false});
                    });

                    // Right trigger
                    this.el.addEventListener("triggerdown", function(event) {
                        self.el.emit('righttriggerpressed', {pressed: true});
                    });

                    this.el.addEventListener("triggerup", function(event) {
                        self.el.emit('righttriggerreleased', {pressed: false});
                    });

                    // Thumbstick
                    this.el.addEventListener("thumbstickmoved", function(event) {
                        self.el.emit('thumbstickmoved', {x: event.detail.x, y: event.detail.y});
                    });
                },
                tick: function() {
                    let player = document.querySelector("#player");
                    let direction = new THREE.Vector3();
                    let left = new THREE.Vector3();

                    // Use the camera's direction for movement
                    player.object3D.getWorldDirection(direction);

                    // Invert direction
                    direction.negate();

                    // Calculate left direction
                    left.crossVectors(player.object3D.up, direction);

                    // Calculate movement based on thumbstick position and speed
                    let dx = direction.x * this.leftAxisY * this.data.moveSpeed - left.x * this.leftAxisX * this.data.moveSpeed;
                    let dz = direction.z * this.leftAxisY * this.data.moveSpeed - left.z * this.leftAxisX * this.data.moveSpeed;

                    // Create a new vector for the desired position
                    let desiredPosition = new THREE.Vector3(
                        player.object3D.position.x + dx,
                        player.object3D.position.y,
                        player.object3D.position.z -+ dz
                    );

                    // Smoothly transition to the desired position
                    player.object3D.position.lerp(desiredPosition, this.data.smoothness);
                },
            });


        </script>
        <!--        JUMP AND FALL (BUT NEVER DEATH, STUCK IN THIS ETERNAL LOOP FOREVER. FOREVAAAAAAAAA)-->
        <script>AFRAME.registerComponent('jump', {
                schema: {
                    groundSelector: { type: "string", default: ".ground"},
                },
                init: function () {
                    this.grounds = Array.from(document.querySelectorAll(this.data.groundSelector));
                    this.player = document.querySelector('#player');
                    this.isOverGround = true;
                    this.isOnGround = false;
                    this.isJumping = false;
                    this.jumpHeight = 0.40;
                    this.jumpSpeed = this.jumpHeight;
                    this.fallSpeed = 0.5;
                    this.canJump = true;


                    document.querySelector('#left-controller').addEventListener('lefttriggerpressed', function(evt) {
                        if (evt === true && !this.isJumping) {
                            if (this.canJump == true) {
                                this.isJumping = true;
                                this.jumpSpeed = this.jumpHeight;
                                this.isOnGround = false;
                            }
                        }
                    });

                    window.addEventListener('keydown', (event) => {
                        if (event.key === ' ' && !this.isJumping) {
                            if (this.canJump == true) {
                                this.isJumping = true;
                                this.jumpSpeed = this.jumpHeight;
                                this.isOnGround = false;
                            }
                        }
                    });
                },
                tick: function () {
                    const currentPosition = this.player.object3D.position;
                    this.grounds = document.querySelectorAll(this.data.groundSelector);
                    this.isOverGround;
                    this.isJumping;
                    let lowY, highY;


                    //see if we're over/under any platforms excluding playheads
                    this.groundCheck = Array.from(this.grounds).reduce((result, ground) => {

                        halfGroundX = parseFloat(ground.getAttribute("width") / 2);
                        halfGroundZ = parseFloat(ground.getAttribute("depth") / 2);
                        groundPosition = ground.getAttribute("position");
                        groundY = parseFloat(ground.getAttribute("height"));
                        newYLevel = groundY+groundPosition.y;  

                        const isOverGround = currentPosition.x >= groundPosition.x - halfGroundX &&
                              currentPosition.x <= groundPosition.x + halfGroundX &&
                              currentPosition.z >= groundPosition.z - halfGroundZ &&
                              currentPosition.z <= groundPosition.z + halfGroundZ;

                        if (isOverGround && halfGroundX === result.halfGroundX && halfGroundZ === result.halfGroundZ) {
                            if (ground.id !== "playhead") {
                                if (newYLevel < result.lowY) {
                                    result.lowY = newYLevel;
                                }
                                if (newYLevel > result.highY) {
                                    result.highY = newYLevel;
                                }
                            }
                            return result;
                        } else if (isOverGround) {
                            return {
                                isOverGround: true,
                                groundY: newYLevel,
                                halfGroundX: halfGroundX, 
                                halfGroundZ: halfGroundZ,
                                lowY: newYLevel,
                                highY: (ground.id === "playhead") ? 0 : newYLevel
                            };
                        } else {
                            return result;
                        }
                    }, { isOverGround: false, groundY: 0, halfGroundX: 0, halfGroundZ: 0, lowY: 0, highY: 0 });

                    if (!this.isJumping && this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY + 0.1) {
                        this.isOnGround = true;
                    } else {
                        this.isOnGround = false;
                    }
                    if (this.isOnGround && !this.isJumping) {
                        this.canJump = true;
                    }

                    //send our values for sound
                    if (this.isJumping !== this.prevIsJumping || this.groundCheck.isOverGround !== this.groundCheck.prevIsOverGround) {
                        this.prevIsJumping = this.isJumping;
                        this.groundCheck.prevIsOverGround = this.groundCheck.isOverGround;
                        this.el.emit('state-changed', {isJumping: this.isJumping, isOverGround: this.groundCheck.isOverGround});
                    }
                    //gotta jump up jump up to get down
                    if (this.isJumping) {

                        this.jumpSpeed -= 0.01;
                        const newY = Math.max(currentPosition.y + this.jumpSpeed,this.groundCheck.lowY);

                        let clamp;
                        if(newY >= this.groundCheck.lowY && newY <= this.groundCheck.highY){
                            this.jumpSpeed -=0.01;
                            clamp = Math.max(newY, this.groundCheck.lowY);  
                        } else 
                            if(newY >= this.groundCheck.highY){
                                clamp = Math.max(newY,this.groundCheck.highY);   
                            }
                        this.player.object3D.position.set(currentPosition.x, clamp, currentPosition.z);

                        if (this.jumpSpeed <= -this.fallSpeed) {
                            this.isJumping = false;
                        }
                    } 
                    //so we can land on other platforms jumping from a different height
                    else if(this.groundCheck.isOverGround && currentPosition.y >= this.groundCheck.groundY-0.6|| !this.groundCheck.isOverGround && currentPosition.y > this.groundCheck.lowY){
                        this.jumpSpeed = 0.;
                        let fall = -0.5;

                        if(currentPosition.y >= this.groundCheck.highY){
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.highY);
                            const clamped = Math.max(newY,this.groundCheck.lowY);
                            this.player.object3D.position.set(currentPosition.x, clamped, currentPosition.z);
                            this.canJump = true; 
                            this.jumpSpeed = this.jumpHeight;
                        } else {
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.lowY);
                            //const clamped = Math.max(newY,this.groundCheck.lowY);
                            this.player.object3D.position.set(currentPosition.x, newY, currentPosition.z);
                            this.canJump = true; 
                            this.jumpSpeed =this.jumpHeight;
                        }
                    }
                    //fall off the edge
                    else if(!this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall;
                        this.player.object3D.position.set(currentPosition.x, newY, currentPosition.z);
                        this.canJump = false;
                    }
                    //get rid of the hang if player moves back under ground to trigger is overground bool
                    else if(this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall
                        this.player.object3D.position.set(currentPosition.x,newY, currentPosition.z);
                        this.canJump = false;
                    }
                    //reset the player if they fall too far
                    if(currentPosition.y <= -82){
                        //make sure y is platformSize innit
                        this.player.object3D.position.set(0, 2, 8);
                    }
                },
            });
        </script>
        <!--        COLLIDING BOXES AKA PLATFORMS-->
        <script>AFRAME.registerComponent("box-collider", {
                schema: {
                    hasBonked: { type: 'boolean', default: false }
                },
                init: function () {
                    this.player = document.querySelector("#player");
                    this.collected = false;
                    this.hasBonked = false;
                    this.hasEnded = false;
                    this.distanceThreshold = 4;
                },
                tick: function () {
                    this.player = document.querySelector("#player");
                    const playerPos = new THREE.Vector3();
                    const playerObj3D = this.player.object3D;
                    playerObj3D.getWorldPosition(playerPos);

                    const playerScale = this.player.getAttribute("scale");
                    const boxPos = this.el.object3D.position;
                    const bosRot = this.el.object3D.rotation;
                    const boxID = this.el.getAttribute("id");
                    const boxScale = this.el.getAttribute("scale");

                    const distance = playerPos.distanceTo(boxPos);

                    //check for collisions within the distance threshold
                    if (distance <= this.distanceThreshold) {

                        const halfWidthBox = 0.5 * parseFloat(this.el.getAttribute("width"));
                        const halfHeightBox = 0.5 * parseFloat(this.el.getAttribute("height"));
                        const halfDepthBox = 0.5 * parseFloat(this.el.getAttribute("depth"));

                        const halfWidthPlayer = 0.5 * parseFloat(this.player.getAttribute("width"));
                        const halfHeightPlayer = 0.5 * parseFloat(this.player.getAttribute("height"));
                        const halfDepthPlayer = 0.5  * parseFloat(this.player.getAttribute("depth"));

                        //distances
                        const dx = playerPos.x - boxPos.x;
                        const dy = playerPos.y - boxPos.y;
                        const dz = playerPos.z - boxPos.z;
                        //take the right face
                        const overlapX = halfWidthBox + halfWidthPlayer - Math.abs(dx);
                        const overlapY = halfHeightBox + halfHeightPlayer - Math.abs(dy);
                        const overlapZ = halfDepthBox + halfDepthPlayer - Math.abs(dz);

                        if (overlapX > 0 && overlapY >= 0 && overlapZ > 0) {
                            const minOverlap = Math.min(overlapX, overlapY, overlapZ);
                            if (minOverlap === overlapX) {
                                if(dx > 0){
                                    this.handleCollision(boxID, "x", halfWidthBox, halfWidthPlayer, boxPos.x, playerPos);
                                } 
                                else {
                                    this.handleCollision(boxID, "-x", halfWidthBox, halfWidthPlayer, boxPos.x, playerPos);
                                }
                            } else if (minOverlap === overlapY) {
                                if(dy > 0){
                                    this.handleCollision(boxID, "y", halfHeightBox, halfHeightPlayer, boxPos.y, playerPos);
                                }
                                else {
                                    this.handleCollision(boxID, "-y", halfHeightBox, halfHeightPlayer, boxPos.y, playerPos);
                                }
                            } else if (minOverlap === overlapZ) {
                                if(dz > 0) {
                                    this.handleCollision(boxID, "z", halfDepthBox, halfDepthPlayer, boxPos.z, playerPos);
                                }
                                else {
                                    this.handleCollision(boxID, "-z", halfDepthBox, halfDepthPlayer, boxPos.z, playerPos);
                                }
                            }
                        }
                    }
                },
                handleCollision: function(boxID, direction, halfBoxSize, halfPlayerSize, boxPos, playerPos) {
                    switch (boxID) {
                        case "platform":
                            if (direction === "x" || direction === "-x") {
                                playerPos.x = direction === "x" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            } else if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            } else if (direction === "z" || direction === "-z") {
                                playerPos.z = direction === "z" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            }
                            break;
                        case "playhead":
                            if (direction === "x" || direction === "-x") {
                                playerPos.x = direction === "x" ? boxPos + (halfBoxSize * 2) + halfPlayerSize + 3.1 : boxPos - (halfBoxSize * 2) - halfPlayerSize - 3.1;
                            } else if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            } else if (direction === "z" || direction === "-z") {
                                playerPos.z = direction === "z" ? boxPos + (halfBoxSize * 2) + halfPlayerSize + 3.1 : boxPos - (halfBoxSize * 2) - halfPlayerSize - 3.1;
                            }
                            this.hasBonked = true;
                            this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });
                            break;
                        case "collectable":
                            this.collected = true;
                            this.el.emit('collected', { detail: {collected: this.collected}});
                            break;
                        case "lurker":
                            this.hasEnded = true;
                            this.el.sceneEl.emit('hasEnded', {detail: {hasEnded: this.hasEnded}});
                            if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            }
                            break;
                    }
                    this.player.object3D.position.copy(playerPos);
                },
            });



        </script>
        <!--        WE GOT A LURKER HERE PEOPLE-->
        <script>      AFRAME.registerComponent("lurker", {
                schema: {
                    target: { type: "selector" },
                    easingFactor: { type: "number", default: 0.03 },
                    offset: { type: "number", default: 0 },
                },

                init: function () {
                    // Store the initial Y position
                    this.initialY = this.el.object3D.position.y;
                    // Create a new Vector3 for the target's world position and direction
                    this.targetWorldPosition = new THREE.Vector3();
                    this.offsetVector = new THREE.Vector3();
                },

                tick: function () {
                    // Get the target's world position considering the entire scene hierarchy
                    this.data.target.object3D.getWorldPosition(this.targetWorldPosition);

                    // Get the target's rotation
                    const targetRotation = this.data.target.object3D.rotation;

                    // Calculate the offset position based on the target's rotation
                    this.offsetVector.set(
                        -Math.sin(targetRotation.y) * this.data.offset,
                        0,
                        -Math.cos(targetRotation.y) * this.data.offset
                    );

                    // Apply easing to X and Z positions with the offset
                    this.el.object3D.position.x +=
                        (this.targetWorldPosition.x + this.offsetVector.x - this.el.object3D.position.x) * this.data.easingFactor;
                    this.el.object3D.position.z +=
                        (this.targetWorldPosition.z + this.offsetVector.z - this.el.object3D.position.z) * this.data.easingFactor;

                    // Keep the Y position constant using the stored initial Y value
                    this.el.object3D.position.y = this.initialY;
                },
            });
        </script>
        <div id = "synths"></div>
    </head>
    <body>
        <a-scene background="color: #005AFF">
            <!--vr controller-->
            <a-entity id="left-controller" oculus-touch-controls="hand: left" controller></a-entity>
            <a-entity id="right-controller" oculus-touch-controls="hand: right" controller></a-entity>
            <!--this is where the magic happens-->
            <a-entity class="ground" id="platformsEntity"></a-entity>
            <!--player/camera-->
            <a-entity id="player" camera position="0 1.6 6"width="1.0" height="2"depth="1" look-controls wasd-controls="acceleration: 60" jump>
            </a-entity>
<!--
            <a-entity id="player" position="0 -1 6"width="1.0" height="2"depth="1" look-controls wasd-controls="acceleration: 60" jump><camera position="0 1.6 0"> </camera>
            </a-entity>-->
            <!--killplane-->
            <a-plane id="killplane" side="double" position="0 -18 0" rotation="-90 0 0" width="500" height="500" color="red"></a-plane>
            <!--start point-->
            <a-box class="ground" id="start" position="0 -0.75 6" width="6" height="1" depth="6" color="white"></a-box>
            <!--end point-->
            <a-box class='end' id="lurker" position="0 28 -15" width="4" height="0.25" depth="4" color="black" box-collider lurker="target: #player "></a-box>
        </a-scene>
        <script>
            let tempo = 96;
            let enemySynth;
            let backingMidSynth;
            let bassSynth;
            let sampler; 
            let staging = 0;
            let soundUP = false;
            //we jammin, and i hope you like jammin too
            var dm79 = [50, 57, 64, 65, 72];
            var eb911 = [51, 58, 65, 67, 69];
            var a7sus4 = [45, 57, 64, 67,47];
            var cadd9 = [48, 62, 64, 67, 72];
            let myDrumSequence = [
                {p:4, s:0, v:10},
                {p:4, s:4, v:20},
                {p:4, s:8, v:40},
                {p:4, s:12, v:60}];

            // make clear that the origin is on mimicproject
            var origin = "https://mimicproject.com/libs";
            // pass the origin in when loading your instruments
            const instruments = new MaxiInstruments(origin);
            let scene = document.querySelector('a-scene');
            let player= document.getElementById('player');
            let platformsEntity = document.getElementById('platformsEntity');
            let destroyStep = false;
            let platforms = [];
            let reorderedPlatforms =[];
            let playheads = [];
            let collectables = [];
            let stepSequenceLength = 16;
            let stepOffset = 0;
            let stepCheck = 0;
            let branchID = 0;
            let currentBranch = 0;
            let platformSize = 2;
            let previousOrientation = '-z';
            let metro = 0;
            let doubleMetro = 0;
            let collectableCount = 0;
            let collectablesFound = 0;
            let collectablePicked = false;
            let difficulty = 0;
            let eventFixer = 0;
            let movingCollectablesLocations =[];
            let score = 0;
            let keyPressed='';
            let hasEnded = false;
            let canStart = false;
            let isJumping = false;
            let isOverGround = true;
            let currentPlayerStep;
            let kickTrigger = false;
            let snareTrigger = false;
            let hihatTrigger = false;
            let bellTrigger = false;
            let sequenceTrigger = false;
            var selector = -1;
            let sequenceOrder = [-1];
            let playerSteps = [];
            let totalSteps = 0;
            let kicks = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let snares= [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let hihats=[false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let bells = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];

            //things that trigger sound
            let hasBonked = false;
            let bonking = 0;
            //bonk notes
            let notes = [62, 64, 65, 69 ];
            let reverb = 0;
            let roomSize = 0;
            let filter = 0.1;

            //initialise our environment
            function startup(){
                canStart = false;
                //Create the first sequence of platforms
                for(let i = stepSequenceLength-1; i >= 0 ; i--){
                    let platform = document.createElement('a-box');
                    platform.setAttribute('class', 'ground');
                    platform.setAttribute('id', 'platform');
                    let calc = Math.round(Math.abs((255/16) *i));
                    let rgbString = `rgb(${calc}, ${calc}, ${calc})`;
                    platform.setAttribute('material', 'color', rgbString);
                    //platform.setAttribute('material', {color: rgbString, transparent: 'true', opacity: '0.5'});

                    platform.setAttribute('position', {x: 0, y: 0, z: -i*platformSize});
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute('box-collider', '');
                    //step is 15-i because i original built it backwards like a fucking idiot
                    platforms.push({p: platform, s: 15-i, o: stepOffset, branch: branchID, sound: 'tick', orientation: '-z'});
                    reorderedPlatforms.push(false);
                    platformsEntity.appendChild(platform);
                }
                //lets make it look cooler for the 0 platform/also easier! 
                platforms[0].p.setAttribute('width', platformSize*3);
                platforms[0].p.setAttribute('depth', platformSize*3);
                //Create the first playhead for platforms
                let playhead = document.createElement('a-box');
                playhead.setAttribute('class', "playheads");
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                playhead.setAttribute('side', 'double');
                playhead.setAttribute('position', {x:0, y: platformSize+0.01, z: 0});
                playhead.setAttribute('width', platformSize-0.1);
                playhead.setAttribute("height", platformSize-0.1);
                playhead.setAttribute("depth", platformSize-0.1);
                //playhead.setAttribute("box-collider", ''); 
                playheads.push({p: playhead, o: '-z',startX: 0 , startZ: 0, modDel: 0, modmult: 1});
                platformsEntity.appendChild(playhead);

                //create the first collectable
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('position', {x: 0, y: platformSize, z: -platformSize*(stepSequenceLength-1)});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', platformSize / 6);
                collectable.setAttribute("height", platformSize / 6);
                collectable.setAttribute("depth", platformSize / 6);
                collectable.setAttribute("box-collider", '');
                collectables.push(collectable);
                platformsEntity.appendChild(collectable);  
            }
            startup();
            //Append the platform with everything a single platform has to the scene
            scene.appendChild(platformsEntity);
            //Don't run script until we have a scene!
            if (scene.hasLoaded) {
                run();
            } else {
                scene.addEventListener('loaded', run);
            }
            document.addEventListener('DOMContentLoaded', function() {
                let leftController = document.querySelector('#left-controller');
                let rightController = document.querySelector('#right-controller');

                // X button
                leftController.addEventListener('xbuttonpressed', function(evt) {
                    if(evt.detail.pressed) {
                        kickTrigger = true;
                    }
                });

                leftController.addEventListener('xbuttonreleased', function(evt) {
                    kickTrigger = false;
                });

                // Y button
                leftController.addEventListener('ybuttonpressed', function(evt) {
                    if(evt.detail.pressed) {
                        bellTrigger = true;
                    }
                });

                leftController.addEventListener('ybuttonreleased', function(evt) {
                    bellTrigger = false;
                });

                // A button
                rightController.addEventListener('abuttonpressed', function(evt) {
                    if(evt.detail.pressed) {
                        snareTrigger = true;
                    }
                });

                rightController.addEventListener('abuttonreleased', function(evt) {
                    snareTrigger = false;
                });

                // B button
                rightController.addEventListener('bbuttonpressed', function(evt) {
                    if(evt.detail.pressed) {
                        hihatTrigger = true;
                    }
                });

                rightController.addEventListener('bbuttonreleased', function(evt) {
                    hihatTrigger = false;
                });

                // Left Trigger
                leftController.addEventListener('lefttriggerpressed', function(evt) {
                    isJumping = true;
                });

                leftController.addEventListener('lefttriggerreleased', function(evt) {
                    isJumping = false;
                });

                // Right Trigger
                rightController.addEventListener('righttriggerpressed', function(evt) {
                    destroyStep = true;
                });

                rightController.addEventListener('righttriggerreleased', function(evt) {
                    destroyStep = false;
                });

                // Thumbstick
                leftController.addEventListener('thumbstickmoved', function(evt) {
                    soundUp = true;
                });

                rightController.addEventListener('thumbstickmoved', function(evt) {
                });
            });
            //inputs key down
            document.addEventListener("keydown", function(event) {
                if(event.key == '1'){
                    kickTrigger = true;
                }
                if(event.key == '2'){
                    snareTrigger = true;
                }
                if(event.key == '3'){
                    hihatTrigger = true;
                }
                if(event.key == '4'){
                    bellTrigger = true;
                }
                if(event.key == 'q' || event.key == 'Q'){
                    destroyStep = true;
                }     
                keyPressed = event.key;
            });
            //inputs key up
            document.addEventListener("keyup", function(event) {
                if(event.key == '1'){
                    kickTrigger = false;
                }
                if(event.key == '2'){
                    snareTrigger = false;
                }
                if(event.key == '3'){
                    hihatTrigger = false;
                }
                if(event.key == '4'){
                    bellTrigger = false;
                }
                if(event.key == 'q' || event.key == 'Q'){
                    destroyStep = false;
                } 
                keyPressed = event.key;
            });
            //have we collected collectable? 
            function logCollected(event) {
                const collectable = document.getElementById('collectable');
                collectableCount += 1;
                collectablesFound += 1;
                collectablePicked = true;
                for(let i = 0; i < collectables.length; i++){   
                    collectables.splice(i,1);
                    platformsEntity.removeChild(collectable);
                }
            }
            function setupEventListener(entity) {
                // Remove any old event listeners
                entity.removeEventListener('collected', logCollected);
                // Add a new event listener
                entity.addEventListener('collected', logCollected);
            }
            document.addEventListener('DOMContentLoaded', () => {
                const entity = document.querySelector('#collectable');
                setupEventListener(entity);
            });
            //add event listener for new collectable
            function onNewEntityAdded(entity) {
                setupEventListener(entity);
            }
            //check if we're jump and overground for collectible use
            document.addEventListener('DOMContentLoaded', function() {
                let player = document.querySelector('#player');
                player.addEventListener('state-changed', function(event) {
                    isJumping = event.detail.isJumping;
                    isOverGround = event.detail.isOverGround;
                });
            });
            //playhead collision
            document.addEventListener('DOMContentLoaded', function () {
                //get the scene
                const scene = document.querySelector('a-scene');
                //event listener for the 'bonked' event
                scene.addEventListener('bonked', function (event) {
                    hasBonked = true;
                });
                scene.addEventListener('hasEnded', function (event){

                    // use the boolean value as needed
                    hasEnded = true;
                })
            });
            //which direction are we facing
            function headingDirection(player) {
                const rotation = player.getAttribute("rotation");
                let heading = rotation.y;
                //normalize direction
                heading = (heading + 360000) % 360;

                let facing = "";
                if (heading >= 0 && heading <= 45 || heading > 315 && heading < 360) {
                    facing = "northWest";
                } else if (heading > 45 && heading <= 90) {
                    facing = "westNorth";
                } else if (heading > 90 && heading <= 135) {
                    facing = "westSouth";
                } else if (heading > 135 && heading <= 180) {
                    facing = "southWest";
                } else if (heading > 180 && heading <= 225) {
                    facing = "southEast";
                } else if (heading > 225 && heading <= 270) {
                    facing = "eastSouth";
                } else if (heading > 270 && heading <= 315) {
                    facing = "eastNorth";
                }
                return facing;
            }
            //spend collectables (to generate platforms)
            function useCollectables(player, facing, inputs) {
                const playerPos = player.getAttribute('position');

                if (collectableCount <= 0 || isOverGround !== true || isJumping === true) {
                    return;
                }
                const validInputs = ['1', '2', '3', '4'];
                if (!validInputs.includes(inputs)) {
                    return;
                }
                const directions = {
                    northWest: { x: '-x', z: '-z' },
                    westNorth: { x: '-x', z: '-z' },
                    westSouth: { x: '-x', z: 'z' },
                    southWest: { x: '-x', z: 'z' },
                    southEast: { x: 'x', z: 'z' },
                    eastSouth: { x: 'x', z: 'z' },
                    eastNorth: { x: 'x', z: '-z' },
                    northEast: { x: 'x', z: '-z' },
                };
                const direction = directions[facing];

                if (!direction) {
                    return;
                }

                let newOrientation;
                if (previousOrientation === 'z' || previousOrientation === '-z') {
                    newOrientation = (direction.x === 'x' || direction.x === '-x') ? direction.x : direction.z;
                } else {
                    newOrientation = (direction.z === 'z' || direction.z === '-z') ? direction.z : direction.x;
                }
                //                /stepSequencer();
                generatePlatforms(playerPos, stepSequenceLength, inputs, newOrientation);
                previousOrientation = newOrientation;
            }
            //we move this shit
            function movePlayheads() {
                const reverseOffset = (stepSequenceLength - 1) * platformSize;

                for (let i = 0; i < playheads.length; i++) {
                    let localMetro = playheads[i].modmult == 2 ? doubleMetro : metro;
                    let modMetro = -(localMetro - playheads[i].modDel) % stepSequenceLength;

                    const playheadPos = playheads[i].p.getAttribute('position');
                    const playheadSize = parseFloat(playheads[i].p.getAttribute('width'));

                    let normalisedStart, difference, newPosition;

                    if (playheads[i].o == "-z" || playheads[i].o == "z") {
                        normalisedStart = (Math.abs(playheads[i].startX) / platformSize);
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newZ = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheadPos.x,
                            y: playheadPos.y,
                            z: playheads[i].o == "-z"
                            ? playheads[i].startZ + newZ - reverseOffset
                            : playheads[i].startZ - newZ + reverseOffset
                        };
                    } else {
                        normalisedStart = (Math.abs(playheads[i].startZ) / platformSize) % stepSequenceLength;
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newX = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheads[i].o == "-x"
                            ? playheads[i].startX + newX - reverseOffset
                            : playheads[i].startX - newX + reverseOffset,
                            y: playheadPos.y,
                            z: playheadPos.z
                        };
                    }

                    playheads[i].p.setAttribute('position', newPosition);
                }
            }
            //everything makes platforms appear
            function generatePlatforms(playerPos, numSteps, inputs, orientation){
                //make sure we turn off our collectable
                collectableCount--;
                difficultyMapper();

                //floor playerX and Z so we don't prematurely slide off of platform edge
                let playerFlooredX = Math.floor(0.5+(playerPos.x)/platformSize)*platformSize;
                let playerFlooredZ = Math.floor(0.5+(playerPos.z)/platformSize)*platformSize;

                //update the offset for our step sequencer based on what platform we are over when we generate new ones. 
                //stepOffset = currentPlayerStep + stepOffset%16;
                stepOffset = ((stepOffset + stepCheck)%16);
                //console.log("stepOffset", stepOffset);
                //increment placementID - this is used so we can keep track of which platforms relate to which placement (useful for deletion)
                branchID = branchID + 1;

                //change colour of platforms based on input type
                r = 255;
                g = 255;
                b = 255;

                let platformLabel;

                switch (inputs) {
                    case '1':
                        platformLabel = 'kicks';
                        r = 255;
                        g = 165;
                        b = 0;
                        break;
                    case '2':
                        platformLabel = 'snares';
                        r = 255;
                        g = 210;
                        b = 128;
                        break;
                    case '3':
                        platformLabel = 'hihats';
                        r = 0;
                        g = 191;
                        b = 123;
                        break;
                    case '4':
                        platformLabel = 'bells';
                        r = 0;
                        g = 255;
                        b = 165;
                        break;
                    default:
                        break;
                }
                //generate our platform floor 
                for(let i = numSteps-1; i >= 0; i--){
                    let platform = document.createElement('a-box');
                    platform.setAttribute('class', 'ground');
                    platform.setAttribute('id', 'platform' );
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute('scale',  {x: 1, y: 1, z: 1});
                    platform.setAttribute('box-collider', '');
                    //colour the new platforms with a sick fade yo
                    calcR = r-Math.round(Math.abs((r/numSteps) *(i%numSteps)));
                    calcG = g-Math.round(Math.abs((g/numSteps) *(i%numSteps)));
                    calcB = b-Math.round(Math.abs((b/numSteps) *(i%numSteps)));; 
                    let rgbString = `rgb(${calcR}, ${calcG}, ${calcB})`;
                    platform.setAttribute('color', rgbString);  
                    //platform.setAttribute('material', {color: rgbString, transparent: 'true', opacity: '0.5'});

                    //set position based on player orientation
                    if(orientation == '-x'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX -(i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            } else {
                                platform.setAttribute('position', {x: playerFlooredX +(-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        } else {
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX -(i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            } else {
                                platform.setAttribute('position', {x: playerFlooredX +(-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                    } 
                    else if(orientation == '-z'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX < 0){
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            } else {
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }
                        } else  {
                            if(playerFlooredX <=0){
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }else {
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }
                        }
                    }
                    else if(orientation == 'z'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX <0){
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            } else {
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            }
                        } else {
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ - (-i *platformSize)});
                            } else{
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            }
                        }
                    }
                    else if(orientation == 'x'){
                        if(playerFlooredZ <= 0){
                            if(playerFlooredX < 0){
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }else {
                                platform.setAttribute('position', {x: playerFlooredX - (-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                        else{
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});

                            } else{
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                    }
                    platforms.push({p:platform, s: 15-i, o: 0, branch: branchID, sound: platformLabel, orientation: orientation});

                    platformsEntity.appendChild(platform);
                }
                //playhead biz
                let playhead = document.createElement('a-box');
                playhead.setAttribute('class', 'playheads');
                //playhead.setAttribute("box-collider", '');
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                playhead.setAttribute('side', 'double');

                //use a lil bit of rng to spice up the chance
                let rng = Math.random();

                //our kick PlayHeads
                if(sequenceOrder[sequenceOrder.length-1] == 0){
                    playhead.setAttribute('width', (platformSize*3)-0.01);
                    playhead.setAttribute("height", platformSize-0.01);
                    playhead.setAttribute("depth", (platformSize*3)-0.01);
                    //snare playheads
                } 
                else if(sequenceOrder[sequenceOrder.length-1] == 1){
                    playhead.setAttribute('width', (platformSize/2)-0.1);
                    playhead.setAttribute("height",(platformSize*3)-0.1);
                    playhead.setAttribute("depth", (platformSize/2)-0.1);
                    //hihat playheads
                } 
                else if(sequenceOrder[sequenceOrder.length-1] == 2){
                    if (orientation == 'x' || orientation == '-x'){
                        playhead.setAttribute('width', (platformSize*4)-0.1);
                        playhead.setAttribute("height",(platformSize/4)-0.1);
                        playhead.setAttribute("depth", (platformSize/4)-0.1);   
                    } else {
                        playhead.setAttribute('width', (platformSize/4)-0.1);
                        playhead.setAttribute("height",(platformSize/4)-0.1);
                        playhead.setAttribute("depth", (platformSize*4)-0.1);     
                    }
                } 
                else{
                    if (orientation == 'x' || orientation == '-x'){
                        playhead.setAttribute('width', platformSize-0.1);
                        playhead.setAttribute("height",(platformSize/4)-0.1);
                        playhead.setAttribute("depth", (platformSize*3)-0.1);   
                    } else {
                        playhead.setAttribute('width', (platformSize*3)-0.1);
                        playhead.setAttribute("height",(platformSize/4)-0.1);
                        playhead.setAttribute("depth", platformSize-0.1);     
                    }
                } 
                //                }
                //use difficult to seed playheads with different metroSpeeds
                let modSpeed = 1;
                if(difficulty < 8){
                    modSpeed = 1;
                }
                if(difficulty >=8 && difficulty < 16){  
                    modSpeed = 1; 

                } else if (difficulty >= 16 && difficulty <= 28){
                    if(rng > 0.8){
                        modSpeed =2; 
                    }  else {
                        modSpeed = 1;
                    }
                } else if (difficulty >= 28 && difficulty <=36){
                    if(rng > 0.7){
                        modSpeed =2; 
                    }else{
                        modSpeed = 1;
                    }
                } else if(difficulty > 36 && difficulty <=48){
                    if(rng > 0.3){
                        modSpeed =2; 
                    }else{
                        modSpeed = 1;
                    }
                } 

                //using number of steps to figure out if we need to offset starting point in the cycle
                let val;
                if (playerSteps.length > 3){
                    val = playerSteps[playerSteps.length-1] - playerSteps[playerSteps.length-2];
                } else{
                    val = 0;
                }
                //set orientation
                let newPosition = {x: playerFlooredX, y: playerPos.y + platformSize + 0.001, z: playerFlooredZ};
                playhead.setAttribute('position', newPosition);
                let playheadData = {
                    p: playhead,
                    o: orientation,
                    startX: playerFlooredX,
                    startZ: playerFlooredZ,
                    modDel: stepOffset - currentPlayerStep,
                    modmult: modSpeed
                };
                playheads.push(playheadData);

                //append to entity in scene
                platformsEntity.appendChild(playhead);
                //wait so our platforms positions are updated and then place collectable

                //generate the collectable for that platform
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', platformSize/6);
                collectable.setAttribute("height", platformSize/6);
                collectable.setAttribute("depth", platformSize/6);
                collectable.setAttribute("box-collider", '');

                //quick and dirty as main way is fucked/too computational expensive
                let away = stepSequenceLength-((difficulty/collectablesFound+1)%8)-1;

                if(orientation == '-x'){
                    //ofset the x by the negative of sequence so it places it at the end
                    collectable.setAttribute('position', {x: playerFlooredX -((away)*platformSize), y: platformSize+playerPos.y, z:playerFlooredZ});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == '-z'){      
                    collectable.setAttribute('position', {x: playerFlooredX, y: platformSize+playerPos.y, z:playerFlooredZ-((away)*platformSize)});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == 'z'){
                    collectable.setAttribute('position', {x: playerFlooredX, y: platformSize+playerPos.y, z:playerFlooredZ+((away)*platformSize)});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == 'x'){
                    collectable.setAttribute('position', {x: playerFlooredX +((away)*platformSize), y: platformSize+playerPos.y, z:playerFlooredZ});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize, z: place.z})
                }
                collectables.push(collectable);
                //append to entity in scene
                platformsEntity.appendChild(collectable);
                onNewEntityAdded(collectable);

                //replace our player so they don't get stuck inside the new dropped platform
                player.setAttribute('position', {x: playerPos.x, y: playerPos.y + (platformSize*3)+0.1, z: playerPos.z});

            }
            // use step check and inputs to trigger sound / add them to instrument array 
            function stepSequencer() {
                const playerPos = player.getAttribute('position');
                const playerX = playerPos.x;
                const playerY = playerPos.y;
                const playerZ = playerPos.z;
                const halfPlatformSize = platformSize / 2;

                for (let i = 0; i < platforms.length; i++) {
                    const platformPos = platforms[i].p.getAttribute('position');
                    const platformX = platformPos.x;
                    const platformY = platformPos.y;
                    const platformZ = platformPos.z;

                    if (
                        playerX > platformX - halfPlatformSize &&
                        playerX < platformX + halfPlatformSize &&
                        playerY >= platformY &&
                        playerY <= platformY + (platformSize + 1.1) &&
                        playerZ > platformZ - halfPlatformSize &&
                        playerZ < platformZ + halfPlatformSize
                    ) {
                        let standingStep = (platforms[i].s + platforms[i].o) % stepSequenceLength;
                        stepCheck = platforms[i].s;
                        currentPlayerStep = standingStep;
                        currentBranch = platforms[i].branch;

                        if (collectableCount > 0) {
                            const triggerInfo = [
                                { trigger: kickTrigger, index: 0, setFalse: () => kickTrigger = false },
                                { trigger: snareTrigger, index: 1, setFalse: () => snareTrigger = false },
                                { trigger: hihatTrigger, index: 2, setFalse: () => hihatTrigger = false },
                                { trigger: bellTrigger, index: 3, setFalse: () => bellTrigger = false },
                            ];

                            for (const info of triggerInfo) {
                                if (info.trigger) {
                                    myDrumSequence.push({ p: info.index, s: standingStep, v: 127 });
                                    sampler.setSequence(myDrumSequence, 4);
                                    sequenceOrder.push(info.index);
                                    playerSteps.push(currentPlayerStep);
                                    selector = info.index;
                                    info.setFalse();
                                }
                            }
                        }
                    }
                }
            }
            //grab our sample triggers and store them as bools to do stuff with 
            function sequenceTracker(myDrumSequence) {
                for (let i = 0; i < myDrumSequence.length; i++) {
                    const drumItem = myDrumSequence[i];
                    const drumIndex = drumItem.s;

                    if (drumItem.v > 0) {
                        switch (drumItem.p) {
                            case 0:
                                kicks[drumIndex] = true;
                                break;
                            case 1:
                                snares[drumIndex] = true;
                                break;
                            case 2:
                                hihats[drumIndex] = true;
                                break;
                            case 3:
                                bells[drumIndex] = true;
                                break;
                        }
                    }
                }
            }
            //mapped our beats so we can check their distribution
            function mappedBar(bar) {
                //steps mapped
                const stepValues = bar.map((bool, index) => {
                    const mapping = [8, 1, 4, 2];
                    const mappingIndex = index % 4;
                    return bool ? mapping[mappingIndex] : 0;
                });
                // Beat values
                const beatValues = [];
                for (let i = 0; i < stepValues.length; i += 4) {
                    let sum = 0;
                    for (let j = i; j < i + 4; j++) {
                        sum += isNaN(stepValues[j]) ? 0 : stepValues[j];
                    }
                    beatValues.push(sum);
                }           
                return {stepValues, beatValues};
            }; 
            //nifty function for checking individual bar distribution
            function barCheck(beats){
                if(beats[0] > beats[1] && beats[2] & beats[3]){
                    return 5;
                }
                if(beats[1] > beats[0]&& beats[2] && beats[3]){
                    return 10;
                }
                if(beats[2] > beats[0]&& beats[1] && beats[3]){
                    return 5;
                }
                if(beats[3] > beats[0]&& beats[1] && beats[2]){
                    return 5;
                }  else {
                    return 0;
                } 
            }
            //nifty distance calc for how far things are from other things
            function distance3D(a, b) {
                return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow(a.z - b.z, 2));
            }
            //lil scale
            function scale (number, inMin, inMax, outMin, outMax) {
                return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
            }
            //move our collectables around the steps environment based on step distribution
            function difficultyMapper(){
                //mapped bar returns 16 step Values mapped to 8, 1, 4, 2
                let mappedKicks = mappedBar(kicks);
                let mappedSnares = mappedBar(snares);
                let mappedHihats = mappedBar(hihats);
                let mappedBells = mappedBar(bells);
                let allKicksStepValues = mappedBar(kicks).stepValues;
                let allSnaresStepValues = mappedBar(snares).stepValues;
                let allHihatsStepValues = mappedBar(hihats).stepValues;
                let allBellsStepValues = mappedBar(bells).stepValues;
                let allKicksBeatValues = mappedBar(kicks).beatValues;
                let allSnaresBeatValues = mappedBar(snares).beatValues;
                let allHihatsBeatValues = mappedBar(hihats).beatValues;
                let allBellsBeatValues = mappedBar(bells).beatValues;
                //let difficulty = 0;
                //our distances so we know where we're mapping notes too
                let sumKicks = 0;
                let sumSnares = 0;
                let sumHihats = 0;
                let sumBells = 0;
                let sumAllSteps =[];
                //where to play then next collectable
                let collectablePlacement;
                //get sums of all our steps
                for(let i = 0; i < 16; i++){
                    sumKicks += allKicksStepValues[i];
                    sumSnares += allSnaresStepValues[i];
                    sumHihats += allHihatsStepValues[i];
                    sumBells += allBellsStepValues[i];
                    sumAllSteps.push(allKicksStepValues[i]+allSnaresStepValues[i]+allHihatsStepValues[i]+allBellsStepValues[i]);
                }
                //increase difficulty abit every collection
                for(let i = 0; i<collectablesFound; i++){
                    difficulty += 5;
                }
                //increase difficult based on kicks
                if(sumKicks > 12 && sumKicks <=18){
                    difficulty +=25;
                }
                //increase difficulty based on snares
                if(sumSnares > 12 && sumSnares <= 16 ){
                    difficulty +=25;
                } 
                else if (sumSnares > 16){
                    difficulty +=30;
                }
                //increase difficult based on hihats and bells
                if(sumHihats + sumBells > 20){
                    difficulty +=15;
                }
                //reward players if they can manage some parity between distributions
                if(allKicksBeatValues[0] > 0 && allKicksBeatValues[0] == allKicksBeatValues[1] && allKicksBeatValues[2] && allKicksBeatValues[3]){
                    difficulty -=15;
                } 
                if(allHihatsBeatValues[0] > 0 && allHihatsBeatValues[0] == allHihatsBeatValues[1] && allHihatsBeatValues[2] && allHihatsBeatValues[3] || allBellsBeatValues[0] > 0 && allBellsBeatValues[0] == allBellsBeatValues[1] && allBellsBeatValues[2] && allBellsBeatValues[3]){
                    difficulty -=20;
                }
                //when distribution is too lopsided make target location very far way. 
                difficulty = difficulty + barCheck(sumAllSteps);

            }
            //update our collectables / move them around in case one of them gets stuck
            function updateCollectables(){

                let bang = eventFixer%4;
                let tempPos = movingCollectablesLocations[bang];

                for (let i = 0; i < movingCollectablesLocations.length; i++) { 
                    if (typeof movingCollectablesLocations[i] !== 'undefined') {  
                        collectables[0].setAttribute('position', {x: tempPos.x, y: tempPos.y + platformSize, z: tempPos.z})
                    } else {
                        collectables[0].setAttribute('position', {x: place.x, y: place.y, z: place.z})
                    }
                }
            }
            //get the shuffled orderd for our new platform layer
            function reorderSamples(sample, currentPlayerStep) {
                const reordered = [];
                for (let i = 0; i < 16; i++) {
                    reordered[i] = sample[(currentPlayerStep + 1 +  i) % 16];
                }
                return reordered;
            }
            //helper to minimise setAttributes
            function updatePlatformAttributes(platform, width, height, depth) {
                platform.p.setAttribute('width', width);
                platform.p.setAttribute('height', height);
                platform.p.setAttribute('depth', depth);
                platform.p.setAttribute('scale', { x: 1, y: 0.98, z: 1 });
            }
            //update our platforms when we trigger the corresponding step yo
            function updatePlatforms() {
                let base = playerSteps.length * 16;
                let reorderedSamples;

                switch (selector) {
                    case 0:
                        reorderedSamples = reorderSamples(kicks, currentPlayerStep);
                        break;
                    case 1:
                        reorderedSamples = reorderSamples(snares, currentPlayerStep);
                        break;
                    case 2:
                        reorderedSamples = reorderSamples(hihats, currentPlayerStep);
                        break;
                    case 3:
                        reorderedSamples = reorderSamples(bells, currentPlayerStep);
                        break;
                    default:
                        return;
                }
                for (let i = 0; i < reorderedSamples.length; i++) {
                    if (reorderedSamples[i] === true) {


                        let platform = platforms[i + base];

                        switch (selector) {
                            case 0:
                                updatePlatformAttributes(platform, platformSize * 3, platformSize, platformSize * 3);
                                break;
                            case 1:
                                let width = (platform.orientation == 'x' || platform.orientation == '-x') ? platformSize * 2 : platformSize / 2;
                                let depth = (platform.orientation == 'x' || platform.orientation == '-x') ? platformSize / 2 : platformSize * 2;
                                updatePlatformAttributes(platform, width, 9, depth);
                                break;
                            case 2:
                                let hatWidth = (platform.orientation == 'x' || platform.orientation == '-x') ? platformSize * 3 : platformSize / 2;
                                let hatDepth = (platform.orientation == 'x' || platform.orientation == '-x') ? platformSize / 2 : platformSize * 3;
                                updatePlatformAttributes(platform, hatWidth, platformSize / 4, hatDepth);
                                break;
                            case 3:
                                updatePlatformAttributes(platform, platformSize * 3, platformSize, platformSize * 3);
                                break;
                        }
                    }
                }
                selector = -1;
            }
            //destroy our playforms if our players want to do that
            function destroyer(){
                if(destroyStep == true && currentBranch > 0){
                    for (let i = platforms.length - 1; i >= 0; i--) {
                        if (platforms[i].branch === currentBranch) {
                            platforms[i].p.remove();
                            platforms.splice(i, 1); 
                            collectableCount+=1;
                        }
                    }
                }
            }
            //this is where the real magic happens
            function updateSounds(){
                //have we been bonked by a playhead
                if(hasBonked == true){
                    let randomNote = notes[Math.floor(Math.random()*notes.length)];
                    enemySynth.noteon(randomNote, 127);
                    bonking = 1.0;
                    roomSize =1.0;
                    hasBonked = false;
                }
                if(bonking > 0){
                    bonking -= 0.1;
                    reverb += 0.2;
                    enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                }
                if (bonking  <= 0){
                    hasBonked = false;
                    enemySynth.noteoff(62);
                    enemySynth.noteoff(64);
                    enemySynth.noteoff(65);
                    enemySynth.noteoff(69);

                    bonking = 0;
                    enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                } 

                //jump sounds
                if(isJumping == true){
                    filter += 0.5;  
                    backingMidSynth.setParam("lfoFrequency", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                    bassSynth.setParam("cutoff", filter *40);
                    sampler.setParam("rate_1", scale(filter, -2, 1, 0.1, 0.5)) ;
                    sampler.setParam("rate_2", filter+0.5);
                    sampler.setParam("rate_3", filter-0.5);
                } else {
                    filter = 0;
                    backingMidSynth.setParam("lfoFrequency", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                } 
                //falling sounds
                let fall = player.getAttribute('position').y;
                if(fall < -2){
                    let drop = scale(fall,-30,0, 0.5, 0.1);
                    sampler.setParam("rate_0", drop);
                    sampler.setParam("rate_1", drop);
                    bassSynth.setParam("adsrPitchMod", drop*-1000);
                    bassSynth.setParam('cutoff', drop*-100);
                    bassSynth.setParam("lfoFrequency", 10-drop);
                    //                        ,["cutoff", drop*1000],["lfoFrequency", drop],);
                    backingMidSynth.setParam("lfoFrequency", drop);
                    sampler.setParam("rate_4", drop);
                } 
                if(fall <= -70){
                    sampler.setParam("rate_0", 0.5);
                    sampler.setParam("rate_1", 0.5);
                    bassSynth.setParam("adsrPitchMod", 0);
                    //                                        ["cutoff",40]);
                    //backingMidSynth.setParam("reverbMix", 0.12);
                }

                //our arrangement for backing synths
                if(collectablesFound == 1 && collectablePicked == true){

                    bassSynth.setParam('gain', 1);
                    collectablePicked = false;

                }
                if(collectablesFound == 2 && collectablePicked == true){   
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;                        
                    }                    
                }
                if(collectablesFound == 3 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38},{s:4, l:4, p:36},{s:8, l:4, p:33}, {s:12, l:4, p:36}],2);
                        bassSynth.setLoop(16,4);
                        collectablePicked = false;    
                    }   
                }
                if(collectablesFound == 4 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind(); 
                        bassSynth.setSequence([{s:0, l:16, p:33}],1);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    }   
                }
                if(collectablesFound == 5 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38}, {s:0, l:16, p:48}],4);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    } 
                }
                if(collectablesFound == 6 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:8, p:38},{s:8, l:4, p:48},{s:12, l:4, p:45}, {s:16, l:16, p:39}],4);
                        bassSynth.setLoop(32,4);
                        backingMidSynth.setSequence([{s:0, l:8, p:a7sus4},
                                                     {s:16, l:8, p:cadd9},
                                                    ],4);
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;    
                    } 
                }
                if(collectablesFound == 7 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:16, p:38}],1);
                        bassSynth.setLoop(32,4);
                        collectablePicked = false;    
                    }
                }

                enemySynth.getMappedParameters;
                backingMidSynth.getMappedParameters;
                bassSynth.getMappedParameters; 
                sampler.getMappedParameters;

            }
            //end game reset
            function end(){
                if(hasEnded == true){
                    //TURN OFF SOUND SEQUENTIALLY, REMOVE PLATFORMS, FADE/OR DROP PLAYER TO STARTING POINT, RESET ALL NECESSARY VALUES
                    // collectable count, difficulty value, playerSteps, sequenceOrder, Empty all arrays
                    if(metro%16==0){
                        staging++;
                    }
                    if(staging %10){
                        scene.setAttribute('background', 'black');
                    }

                }
            }
            instruments.loadModules().then(()=> {

                enemySynth = instruments.addSynth();
                backingMidSynth = instruments.addSynth();
                bassSynth = instruments.addSynth();
                backingMidSynth.setOsc(1);
                bassSynth.setOsc(1);
                enemySynth.setOsc(1);

                var dm79 = [50, 57, 64, 65, 72];
                var eb911 = [51, 58, 65, 67, 69];
                var a7sus4 = [45, 57, 64, 67,47];
                var cadd9 = [48, 62, 64, 67, 72];

                var midSynthSeq = [
                    //start, length, pitches
                    {s:0, l:8, p:dm79},
                    {s:16, l:8, p:eb911},
                    {s:32, l:8, p:a7sus4},
                    {s:48, l:8, p:cadd9},
                ];
                var bassSynthSeq = [ {s:0, l:16, p:38}];

                backingMidSynth.setParams([
                    ["oscFn",3],
                    ["lfoOscFn",0],
                    ["gain",0.4],
                    ["pan",0.5],
                    ["attack",165],
                    ["decay",330],
                    ["sustain",0.58],
                    ["release",495],
                    ["lfoFrequency",0.7],
                    ["lfoPitchMod",0],
                    ["lfoFilterMod",1000],
                    ["lfoAmpMod",0.68],
                    ["adsrPitchMod",1],
                    ["cutoff",957.6],
                    ["reverbMix",0.33],
                    ["roomSize",0.27],
                    ["delay",0],
                    ["delayMix",0.35],
                    ["frequency",440],
                    ["frequency2",220],
                ]);
                enemySynth.setParams([
                    ["oscFn",3],
                    ["lfoOscFn",1],
                    ["gain",2],
                    ["pan",0.5],
                    ["attack",0],
                    ["decay",330],
                    ["sustain",0.1],
                    ["release",1500],
                    ["lfoFrequency",6.3],
                    ["lfoPitchMod",0],
                    ["lfoFilterMod",220],
                    ["lfoAmpMod",0.88],
                    ["adsrPitchMod",0],
                    ["cutoff",1372],
                    ["reverbMix",0.12],
                    ["roomSize",0],
                    ["delay",0],
                    ["delayMix",0],
                    ["frequency",440],
                    ["frequency2",220],
                ]);
                bassSynth.setParams([
                    ["oscFn",3],
                    ["lfoOscFn",1],
                    ["gain",0],
                    ["pan",0.53],
                    ["attack",1155],
                    ["decay",480],
                    ["sustain",0.58],
                    ["release",1185],
                    ["lfoFrequency",10],
                    ["lfoPitchMod",0],
                    ["lfoFilterMod",1000],
                    ["lfoAmpMod",0.78],
                    ["adsrPitchMod",1],
                    ["cutoff",40],
                    ["reverbMix",0],
                    ["roomSize",0],
                    ["delay",0],
                    ["delayMix",0.35],
                    ["frequency",440],
                    ["frequency2",220],
                ]);

                enemySynth.mapped = ["gain","reverbMix","roomSize", "delay","delayMix"];
                backingMidSynth.mapped = ["gain", "lfoFrequency", "lfoPitchMod", "reverb"];
                bassSynth.mapped = ["lfoFrequency", "pan", "cutoff" ,"adsrPitchMod", "frequency"];

                sampler = instruments.addSampler();
                sampler.loadSample("/sounds/kit1/BD-ER1-CR8000ish.wav", 0);
                sampler.loadSample("/sounds/DR660SnareLofinice.wav", 1);
                sampler.loadSample("/sounds/kit1/TOM-ER-MicroTom2.wav", 2);
                sampler.loadSample("/sounds/kit1/FX-ER-Sonario.wav", 3);
                sampler.loadSample("/sounds/kit1/FX-ER1-Woodzblox.wav", 4);

                sampler.setParam("rate_0", 1);
                sampler.setParam("rate_1", 1);
                sampler.setParam("rate_2", 1);
                sampler.setParam("rate_3", 1);
                sampler.setParam("rate_4", 1);
                sampler.setParam("pan_0", 0.5);
                sampler.setParam("pan_1", 0.5);
                sampler.setParam("pan_2", 0.5);
                sampler.setParam("pan_3", 0.5);
                sampler.setParam("pan_4", 0.5);
                sampler.setParam("gain_0", 1);
                sampler.setParam("gain_1", 1);
                sampler.setParam("gain_2", 1);    
                sampler.setParam("gain_3", 1);    
                sampler.setParam("gain_4", 1);  

                sampler.mapped = ["rate_0", "rate_1", "rate_2", "rate_3", "rate_4"];

                instruments.playPause();
                instruments.setTempo(tempo);
                sampler.setSequence(myDrumSequence, 4);

                //Sequence and loop set at 4 ticks per beat (1/16ths)
                backingMidSynth.setSequence(midSynthSeq, 4);
                bassSynth.setSequence(bassSynthSeq, 4);
                backingMidSynth.setLoop(16,4);
                bassSynth.setLoop(16,4);
                sampler.setLoop(16,4);
                //instruments.setLoop(32,4);

                instruments.setOnTick((playHeads)=> {
                    //The current playhead of the third instrument added
                    if(playHeads[2] % 6 == 2) {
                        metro++;
                    }
                    //double speed
                    if(playHeads[2] % 3 == 2) {
                        doubleMetro++;
                    }
                    if(playHeads[2] % 48 == 4) {
                        sequenceTrigger = true;
                    } 
                });

            }).catch((err)=> {
                console.log("error", err);
            });
            //start the step sequencer
            document.addEventListener('keydown', (event) => {
                if (event.key ){
                    if(soundUP == false){
                        enemySynth.unmute();
                        backingMidSynth.unmute();
                        bassSynth.unmute();
                        sampler.unmute();
                        instruments.playPause();
                        soundUP = true; 
                    } 
                }

            });
            setInterval(run, 50);
            function run() {
                if (soundUP) {
                    movePlayheads();
                    stepSequencer();
                    useCollectables(player, headingDirection(player), keyPressed);
                    updateSounds();
                    sequenceTracker(myDrumSequence);
                    updatePlatforms();
                    destroyer();
                }
                if(hasEnded == true){
                    end();
                }
                if(canStart == true && hasEnded == true){
                    player.setAttribute('position', {x:0, y: 2, z:8});
                    scene.setAttribute('background', {color: 'blue'});
                    killplane.setAttribute('color', 'red');
                    startup();
                    sampler.setParams([["gain_0", 1],["gain_1", 1],["gain_2", 1],["gain_3", 1] ]);
                    bassSynth.setParam('gain', 1);
                    backingMidSynthSeq.setParam('gain', 1);
                    sampler.unmute;
                    backingMidSynth.unmute;
                    bassSynth.unmute;
                    instruments.playPause();
                }
                //sequenceTracker(myDrumSequence);

            }

        </script>
    </body>
</html>
