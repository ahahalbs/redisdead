
<html>
    <head>
        <style>
            #rightHand, #leftHand {
                display: none;
            }
        </style>
        <script src="enable-threads.js"></script>
        <script crossorigin src="maxiInstruments.v.0.7.1.js"></script>
        <script src="./dist/aframe-master.min.js"></script>  
        <!-- 	CONTROL YO SHIT -->
        <!--          <script> -->
        //              AFRAME.registerComponent('controller', {
        //                 schema: {
        //                     moveSpeed: {type: 'number', default: 3.6},
        //                     smoothness: {type: 'number', default: 0.05}
        //                 },
        //                 init: function() {
        //                     this.leftAxisX = 0;
        //                     this.leftAxisY = 0;
        //                     let self = this;

        //                     this.el.addEventListener('thumbstickmoved', function(event) {
        //                         self.leftAxisX = event.detail.x;
        //                         self.leftAxisY = event.detail.y;
        //                     });

        //                     //X button
        //                     this.el.addEventListener('xbuttondown', function(event) {
        //                         self.el.emit('xbuttonpressed', {pressed: true});
        //                     });

        //                     this.el.addEventListener('xbuttonup', function(event) {
        //                         self.el.emit('xbuttonreleased', {pressed: false});
        //                     });

        //                     //Y button
        //                     this.el.addEventListener('ybuttondown', function(event) {
        //                         self.el.emit('ybuttonpressed', {pressed: true});
        //                     });

        //                     this.el.addEventListener('ybuttonup', function(event) {
        //                         self.el.emit('ybuttonreleased', {pressed: false});
        //                     });

        //                     //A button
        //                     this.el.addEventListener('abuttondown', function(event) {
        //                         self.el.emit('abuttonpressed', {pressed: true});
        //                     });

        //                     this.el.addEventListener('abuttonup', function(event) {
        //                         self.el.emit('abuttonreleased', {pressed: false});
        //                     });

        //                     //B button
        //                     this.el.addEventListener('bbuttondown', function(event) {
        //                         self.el.emit('bbuttonpressed', {pressed: true});
        //                     });

        //                     this.el.addEventListener('bbuttonup', function(event) {
        //                         self.el.emit('bbuttonreleased', {pressed: false});
        //                     });

        //                     //left trigger
        //                     this.el.addEventListener('triggerdown', function(event) {
        //                         self.el.emit('lefttriggerdown', {pressed: true});
        //                     });

        //                     this.el.addEventListener('triggerup', function(event) {
        //                         self.el.emit('lefttriggerup', {pressed: false});
        //                     });

        //                     //right trigger
        //                     this.el.addEventListener('triggerdown', function(event) {
        //                         self.el.emit('righttriggerdown', {pressed: true});
        //                     });

        //                     this.el.addEventListener('triggerup', function(event) {
        //                         self.el.emit('righttriggerup', {pressed: false});
        //                     });

        //                     //left grip
        //                     this.el.addEventListener('gripdown', function(event) {
        //                         self.el.emit('leftgripdown', {pressed: true});
        //                     });

        //                     this.el.addEventListener('gripup', function(event) {
        //                         self.el.emit('leftgripup', {pressed: false});
        //                     });

        //                     //right grip
        //                     this.el.addEventListener('gripdown', function(event) {
        //                         self.el.emit('rightgripdown', {pressed: true});
        //                     });

        //                     this.el.addEventListener('gripup', function(event) {
        //                         self.el.emit('rightgripup', {pressed: false});
        //                     });
        //                 },

        //                 tick: function() {
        //                     let player = document.querySelector("#player");
        //                     let camera = document.querySelector("#camera");
        //                     let direction = new THREE.Vector3();
        //                     let left = new THREE.Vector3();

        //                     //camera's direction for movement
        //                     camera.object3D.getWorldDirection(direction);

        //                     //lock y
        //                     direction.y = 0;

        //                     //normalize the direction vector (tsettingy to 0 can fuck vector length)
        //                     direction.normalize();

        //                     //work out left direction
        //                     left.crossVectors(camera.object3D.up, direction);

        //                     //movement based on thumbstick position and speed
        //                     let forwardMovement = direction.multiplyScalar(this.leftAxisY * this.data.moveSpeed);
        //                     let sideMovement = left.multiplyScalar(this.leftAxisX * this.data.moveSpeed);

        //                     //add forward and side movement vectors to get the total movement vector
        //                     let movement = new THREE.Vector3().addVectors(forwardMovement, sideMovement);
        //                     let desiredPosition = new THREE.Vector3().addVectors(player.object3D.position, movement);
        //                     //smooth
        //                     player.object3D.position.lerp(desiredPosition, this.data.smoothness);
        //                 },
        //             });
        <!--         </script> -->
        <!--     JUMP AND FALL (BUT NEVER DEATH, STUCK IN THIS ETERNAL LOOP FOREVAAAAH) -->
        <script>AFRAME.registerComponent('jump', {
                schema: {
                    groundSelector: { type: "string", default: ".ground"},
                },
                init: function () {
                    this.grounds = [];
                    this.player = document.querySelector('#player');
                    this.isOverGround = true;
                    this.isOnGround = false;
                    this.isJumping = false;
                    this.jumpHeight = 0.40;
                    this.jumpSpeed = this.jumpHeight;
                    this.fallSpeed = 0.5;
                    this.canJump = true;
                    this.groundCheck = { isOverGround: false, groundY: 0, halfGroundX: 0, halfGroundZ: 0, lowY: 0, highY: 0 };
                    let self = this; 
                    //initialize
                    this.updateGrounds();

                    this.el.sceneEl.addEventListener('child-attached', this.updateGrounds.bind(this));
                    this.el.sceneEl.addEventListener('child-detached', this.updateGrounds.bind(this));

                    //X
                    document.querySelector('#left-controller').addEventListener('xbuttondown', function(evt) {
                        if (!self.isJumping) {
                            if (self.canJump == true) {
                                self.isJumping = true;
                                self.jumpSpeed = self.jumpHeight;
                                self.isOnGround = false;
                            }
                        }
                    });

                    //A
                    document.querySelector('#right-controller').addEventListener('abuttondown', function(evt) {
                        if (!self.isJumping) {
                            if (self.canJump == true) {
                                self.isJumping = true;
                                self.jumpSpeed = self.jumpHeight;
                                self.isOnGround = false;
                            }
                        }
                    });
                    // Handle space key press
                    window.addEventListener('keydown', (event) => {
                        if (event.key === ' ' && !this.isJumping) {
                            if (this.canJump == true) {
                                this.isJumping = true;
                                this.jumpSpeed = this.jumpHeight;
                                this.isOnGround = false;
                            }
                        }
                    });

                }, updateGrounds: function() {
                    this.grounds = Array.from(document.querySelectorAll(this.data.groundSelector));
                },
                tick: function () {
                    const currentPosition = this.player.object3D.position;
                    let lowY, highY;
                    //see if we're over/under any platforms excluding playheads
                    this.groundCheck = Array.from(this.grounds).reduce((result, ground) => {

                        halfGroundX = ground.getAttribute("width") / 2;
                        halfGroundZ = ground.getAttribute("depth") / 2;
                        groundPosition = ground.getAttribute("position");
                        groundY = parseFloat(ground.getAttribute("height"));
                        newYLevel = groundY+groundPosition.y;  

                        const isOverGround = currentPosition.x >= groundPosition.x - halfGroundX &&
                              currentPosition.x <= groundPosition.x + halfGroundX &&
                              currentPosition.z >= groundPosition.z - halfGroundZ &&
                              currentPosition.z <= groundPosition.z + halfGroundZ;

                        if (isOverGround && halfGroundX === result.halfGroundX && halfGroundZ === result.halfGroundZ) {
                            if (ground.id !== "playhead") {
                                if (newYLevel < result.lowY) {
                                    result.lowY = newYLevel;
                                }
                                if (newYLevel > result.highY) {
                                    result.highY = newYLevel;
                                }
                            }
                            return result;
                        } else if (isOverGround) {
                            return {
                                isOverGround: true,
                                groundY: newYLevel,
                                halfGroundX: halfGroundX, 
                                halfGroundZ: halfGroundZ,
                                lowY: newYLevel,
                                highY: (ground.id === "playhead") ? 0 : newYLevel
                            };
                        } else {
                            return result;
                        }
                    }, { isOverGround: false, groundY: 0, halfGroundX: 0, halfGroundZ: 0, lowY: 0, highY: 0 });

                    if (!this.isJumping && this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY +0.21 ) {
                        this.isOnGround = true;
                    } else {
                        this.isOnGround = false;
                    }
                    if (this.isOnGround && !this.isJumping) {
                        this.canJump = true;
                    }

                    //send our values for sound
                    if (this.isJumping !== this.prevIsJumping || this.groundCheck.isOverGround !== this.groundCheck.prevIsOverGround) {
                        this.prevIsJumping = this.isJumping;
                        this.groundCheck.prevIsOverGround = this.groundCheck.isOverGround;
                        this.el.emit('state-changed', {isJumping: this.isJumping, isOverGround: this.groundCheck.isOverGround});
                    }
                    //gotta jump up jump up to get down
                    if (this.isJumping) {

                        this.jumpSpeed -= 0.01;
                        const newY = Math.max(currentPosition.y + this.jumpSpeed,this.groundCheck.lowY);

                        let clamp;
                        if(newY >= this.groundCheck.lowY && newY <= this.groundCheck.highY){
                            this.jumpSpeed -=0.01;
                            clamp = Math.max(newY, this.groundCheck.lowY);  
                        } else 
                            if(newY >= this.groundCheck.highY){
                                clamp = Math.max(newY,this.groundCheck.highY);   
                            }
                        this.player.object3D.position.set(currentPosition.x, clamp, currentPosition.z);

                        if (this.jumpSpeed <= -this.fallSpeed) {
                            this.isJumping = false;
                        }
                    } 
                    //so we can land on other platforms jumping from a different height
                    else if(this.groundCheck.isOverGround && currentPosition.y >= this.groundCheck.groundY-0.6|| !this.groundCheck.isOverGround && currentPosition.y > this.groundCheck.lowY){
                        this.jumpSpeed = 0.;
                        let fall = -0.5;

                        if(currentPosition.y >= this.groundCheck.highY){
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.highY);
                            const clamped = Math.max(newY,this.groundCheck.lowY);
                            this.player.object3D.position.set(currentPosition.x, clamped, currentPosition.z);
                            this.canJump = true; 
                            this.jumpSpeed = this.jumpHeight;
                        } else {
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.lowY);
                            //const clamped = Math.max(newY,this.groundCheck.lowY);
                            this.player.object3D.position.set(currentPosition.x, newY, currentPosition.z);
                            this.canJump = true; 
                            this.jumpSpeed =this.jumpHeight;
                        }
                    }
                    //fall off the edge
                    else if(!this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall;
                        this.player.object3D.position.set(currentPosition.x, newY, currentPosition.z);
                        this.canJump = false;
                    }
                    //get rid of the hang if player moves back under ground to trigger is overground bool
                    else if(this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall
                        this.player.object3D.position.set(currentPosition.x,newY, currentPosition.z);
                        this.canJump = false;
                    }
                    //reset the player if they fall too far
                    if(currentPosition.y <= -82){
                        //make sure y is platformSize innit
                        this.player.object3D.position.set(0, 2, 8);
                    }
                },
            });
        </script>
        <!--     EVERYTHING COLLIDES -->
        <script>AFRAME.registerComponent("box-collider", {
                schema: {
                    hasBonked: { type: 'boolean', default: false }
                },
                init: function () {
                    this.player = document.querySelector("#player");
                    this.collected = false;
                    this.hasBonked = false;
                    this.hasEnded = false;
                    this.distanceThreshold = 2;
                },
                tick: function () {
                    this.player = document.querySelector("#player");
                    const playerPos = new THREE.Vector3();
                    const playerObj3D = this.player.object3D;
                    playerObj3D.getWorldPosition(playerPos);

                    const playerScale = this.player.getAttribute("scale");
                    const boxPos = this.el.object3D.position;
                    const bosRot = this.el.object3D.rotation;
                    const boxID = this.el.getAttribute("id");
                    const boxScale = this.el.getAttribute("scale");

                    const distance = playerPos.distanceTo(boxPos);

                    //check for collisions within the distance threshold
                    if (distance <= this.distanceThreshold) {

                        const halfWidthBox = 0.5 * parseFloat(this.el.getAttribute("width"));
                        const halfHeightBox = 0.5 * parseFloat(this.el.getAttribute("height"));
                        const halfDepthBox = 0.5 * parseFloat(this.el.getAttribute("depth"));

                        const halfWidthPlayer = 0.5 * parseFloat(this.player.getAttribute("width"));
                        const halfHeightPlayer = 0.5 * parseFloat(this.player.getAttribute("height"));
                        const halfDepthPlayer = 0.5  * parseFloat(this.player.getAttribute("depth"));

                        //distances
                        const dx = playerPos.x - boxPos.x;
                        const dy = playerPos.y - boxPos.y;
                        const dz = playerPos.z - boxPos.z;
                        //take the right face
                        const overlapX = halfWidthBox + halfWidthPlayer - Math.abs(dx);
                        const overlapY = halfHeightBox + halfHeightPlayer - Math.abs(dy);
                        const overlapZ = halfDepthBox + halfDepthPlayer - Math.abs(dz);

                        if (overlapX > 0 && overlapY >= 0 && overlapZ > 0) {
                            const minOverlap = Math.min(overlapX, overlapY, overlapZ);
                            if (minOverlap === overlapX) {
                                if(dx > 0){
                                    this.handleCollision(boxID, "x", halfWidthBox, halfWidthPlayer, boxPos.x, playerPos);
                                } 
                                else {
                                    this.handleCollision(boxID, "-x", halfWidthBox, halfWidthPlayer, boxPos.x, playerPos);
                                }
                            } else if (minOverlap === overlapY) {
                                if(dy > 0){
                                    this.handleCollision(boxID, "y", halfHeightBox, halfHeightPlayer, boxPos.y, playerPos);
                                }
                                else {
                                    this.handleCollision(boxID, "-y", halfHeightBox, halfHeightPlayer, boxPos.y, playerPos);
                                }
                            } else if (minOverlap === overlapZ) {
                                if(dz > 0) {
                                    this.handleCollision(boxID, "z", halfDepthBox, halfDepthPlayer, boxPos.z, playerPos);
                                }
                                else {
                                    this.handleCollision(boxID, "-z", halfDepthBox, halfDepthPlayer, boxPos.z, playerPos);
                                }
                            }
                        }
                    }
                },
                handleCollision: function(boxID, direction, halfBoxSize, halfPlayerSize, boxPos, playerPos) {
                    switch (boxID) {
                        case "platform":
                            if (direction === "x" || direction === "-x") {
                                playerPos.x = direction === "x" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            } else if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            } else if (direction === "z" || direction === "-z") {
                                playerPos.z = direction === "z" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            }
                            break;
                        case "playhead":
                            if (direction === "x" || direction === "-x") {
                                playerPos.x = direction === "x" ? boxPos + (halfBoxSize * 2) + halfPlayerSize + 3.1 : boxPos - (halfBoxSize * 2) - halfPlayerSize - 3.1;
                            } else if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            } else if (direction === "z" || direction === "-z") {
                                playerPos.z = direction === "z" ? boxPos + (halfBoxSize * 2) + halfPlayerSize + 3.1 : boxPos - (halfBoxSize * 2) - halfPlayerSize - 3.1;
                            }
                            this.hasBonked = true;
                            this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });
                            break;
                        case "collectable":
                            this.collected = true;
                            this.el.emit('collected', { detail: {collected: this.collected}});
                            break;
                        case "lurker":
                            this.hasEnded = true;
                            this.el.sceneEl.emit('hasEnded', {detail: {hasEnded: this.hasEnded}});
                            if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            }
                            break;
                    }
                    this.player.object3D.position.copy(playerPos);
                },
            });</script>
        <!--     LURKING -->
        <script>AFRAME.registerComponent("lurker", {
                schema: {
                    target: { type: "selector" },
                    easingFactor: { type: "number", default: 0.03 },
                    offset: { type: "number", default: 0 },
                },

                init: function () {
                    //initial y position
                    this.initialY = this.el.object3D.position.y;
                    //player being targeted
                    this.targetWorldPosition = new THREE.Vector3();
                    this.offsetVector = new THREE.Vector3();
                },

                tick: function () {
                    //world position
                    this.data.target.object3D.getWorldPosition(this.targetWorldPosition);
                    //players rotation
                    const targetRotation = this.data.target.object3D.rotation;
                    //offset position
                    this.offsetVector.set(
                        -Math.sin(targetRotation.y) * this.data.offset,
                        0,
                        -Math.cos(targetRotation.y) * this.data.offset
                    );
                    //easing to x and z positions with the offset
                    this.el.object3D.position.x +=
                        (this.targetWorldPosition.x + this.offsetVector.x - this.el.object3D.position.x) * this.data.easingFactor;
                    this.el.object3D.position.z +=
                        (this.targetWorldPosition.z + this.offsetVector.z - this.el.object3D.position.z) * this.data.easingFactor;
                    //lockY
                    this.el.object3D.position.y = this.initialY;
                },
            });
        </script>
        <script>
            const platformSize = 3;
            AFRAME.registerComponent('kick-playhead', {
                id: 'playhead',
                dependencies: ['geometry', 'material', 'box-collider'],
                init: function() {
                    this.el.setAttribute('geometry', {
                        primitive: 'box',
                        width: (platformSize * 3) - 0.01,
                        height: platformSize - 0.01,
                        depth: (platformSize * 3) - 0.01
                    });
                    this.el.setAttribute('material', {
                        color: 'red',
                        transparent: true,
                        opacity: 0.5,
                        side: 'double' 
                    });
                     this.el.setAttribute('box-collider', '');

                },
            });

            AFRAME.registerComponent('snare-playhead', {
                dependencies: ['geometry', 'material'],
                init: function() {
                    this.el.setAttribute('geometry', {
                        primitive: 'box',
                        width: (platformSize / 2) - 0.1,
                        height: (platformSize * 3) - 0.1,
                        depth: (platformSize / 2) - 0.1
                    });
                    this.el.setAttribute('material', {
                        color: 'red',
                        transparent: true,
                        opacity: 0.5,
                        side: 'double' 

                    });
                },
            });

            AFRAME.registerComponent('hihat-playhead', {
                dependencies: ['geometry', 'material',],
                init: function() {
                    if (orientation === 'x' || orientation === '-x') {
                        this.el.setAttribute('geometry', {
                            primitive: 'box',
                            width: (platformSize * 4) - 0.1,
                            height: (platformSize / 4) - 0.1,
                            depth: (platformSize / 4) - 0.1
                        });
                    } else {
                        this.el.setAttribute('geometry', {
                            primitive: 'box',
                            width: (platformSize / 4) - 0.1,
                            height: (platformSize / 4) - 0.1,
                            depth: (platformSize * 4) - 0.1
                        });
                    }
                    this.el.setAttribute('material', {
                        color: 'red',
                        transparent: true,
                        opacity: 0.5,
                         side: 'double'
                    });
                },
            });

            AFRAME.registerComponent('bell-playhead', {
                dependencies: ['geometry', 'material',],
                init: function() {
                    if (orientation === 'x' || orientation === '-x') {
                        this.el.setAttribute('geometry', {
                            primitive: 'box',
                            width: platformSize - 0.1,
                            height: (platformSize / 4) - 0.1,
                            depth: (platformSize * 3) - 0.1
                        });
                    } else {
                        this.el.setAttribute('geometry', {
                            primitive: 'box',
                            width: (platformSize * 3) - 0.1,
                            height: (platformSize / 4) - 0.1,
                            depth: platformSize - 0.1
                        });
                    }
                    this.el.setAttribute('material', {
                        color: 'red',
                        transparent: true,
                        opacity: 0.5,
                        side: 'double' 
                    });
                },
            });

        </script>
    </head>
    <body>
        <a-scene stats background="color: #005AFF">
            <!--       vr controllers -->
            <a-entity id="left-controller" oculus-touch-controls="hand: left" controller></a-entity>
            <a-entity id="right-controller" oculus-touch-controls="hand: right" controller></a-entity>

            <!--this is where the magic happens-->
            <a-entity class="ground" id="platformsEntity"></a-entity> 

            <!--      vr camera/player/rig/akaballache -->
            <!--             <a-entity id="rig" position="0 0 0" >
<a-entity id="player" position="0 1.6 6" width="1" height="1.6" depth="1" look controls jump>
<a-camera id="camera" camera look controls ></a-camera>
</a-entity>
</a-entity>  -->

            <a-entity id="player" camera position="0 2 8"width="1.0" height="2"depth="1" look-controls wasd-controls="acceleration: 60" jump></a-entity>

            <a-plane id="killplane" side="double" position="0 -18 0" rotation="-90 0 0" width="500" height="500" color="red"></a-plane>
            <!--start point-->
            <a-box class="ground" id="start" position="0 -1 6" width="6" height="1" depth="6" color="white"></a-box>
            <!--end point-->
            <a-box class='end' id="lurker" position="0 28 -15" width="4" height="0.25" depth="4" color="black" box-collider lurker="target: #player "></a-box>  
        </a-scene> 
        <script>
            let tempo = 96;
            let enemySynth;
            let backingMidSynth;
            let bassSynth;
            let sampler; 
            let staging = 0;
            let soundUP = false;
            let readyToPlay= true;
            //we jammin, and i hope you like jammin too
            var dm79 = [50, 57, 64, 65, 72];
            var eb911 = [51, 58, 65, 67, 69];
            var a7sus4 = [45, 57, 64, 67,47];
            var cadd9 = [48, 62, 64, 67, 72];

            var midSynthSeq = [
                //start, length, pitches
                {s:0, l:8, p:dm79},
                {s:16, l:8, p:eb911},
                {s:32, l:8, p:a7sus4},
                {s:48, l:8, p:cadd9},
            ];
            var bassSynthSeq = [ {s:0, l:16, p:38}];
            var bassSynthSeq2 = [
                {s:0, l:14, p:38},
                {s:15, l:6, p:37},
                {s:23, l:5, p:41},
                {s:29, l:2, p:43},
                {s:32, l:14, p:38},
                {s:47, l:6, p:37},
                {s:55, l:4, p:33},
                {s:59, l:2, p:33},
                {s:61, l:1, p:35},
            ];
            let myDrumSequence = [
                {p:4, s:0, v:10},
                {p:4, s:4, v:20},
                {p:4, s:8, v:40},
                {p:4, s:12, v:60}];

            // make clear that the origin is on mimicproject
            var origin = "https://mimicproject.com/libs";
            // pass the origin in when loading your instruments
            const instruments = new MaxiInstruments(origin);
            let scene = document.querySelector('a-scene');
            let player= document.getElementById('player');
            const star = document.getElementById('start');
            let platformsEntity = document.getElementById('platformsEntity');
            let destroyStep = false;
            let platforms = [];
            let reorderedPlatforms =[];
            let playheads = [];
            let collectables = [];
            let stepSequenceLength = 16;
            let stepOffset = 0;
            let stepCheck = 0;
            let branchID = 0;
            let currentBranch = 0;
//             let platformSize = 3;
            let previousOrientation = '-z';
            let metro = 0;
            let lastEventFixer = -1;
            let eventChangeCounter = 0;
            let collectableCount = 0;
            let collectablesFound = 0;
            let collectablePicked = false;
            let difficulty = 0;
            let eventFixer = 0;
            let ins = -1;
            let hasEnded = false;
            let canStart = false;
            let isJumping = false;
            let isOverGround = true;
            let currentPlayerStep;
            let kickTrigger = false;
            let snareTrigger = false;
            let hihatTrigger = false;
            let bellTrigger = false;
            let sequenceTrigger = false;
            var selector = -1;
            let sequenceOrder = [-1];
            let playerSteps = [];
            let totalSteps = 0;
            let kicks = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let snares= [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let hihats= [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let bells = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            //things that trigger sound
            let hasBonked = false;
            let activeNote = null;
            let pauseBonk = false;
            let bonking = 0;
            //bonk notes
            let notes = [62, 64, 65, 69 ];
            let reverb = 0;
            let roomSize = 0;
            let filter = 0.1;

            //initialise our environment
            function startup(){
                canStart = false;
                //create the first sequence of platforms
                for(let i = stepSequenceLength-1; i >= 0 ; i--){
                    let platform = document.createElement('a-box');
                    platform.setAttribute('class', 'ground');
                    platform.setAttribute('id', 'platform');
                    let calc = Math.round(Math.abs((255/16) *i));
                    let rgbString = `rgb(${calc}, ${calc}, ${calc})`;
                    platform.setAttribute('material', 'color', rgbString);
                    platform.setAttribute('position', {x: 0, y: 0, z: -i*platformSize});
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute('box-collider', '');
                    //step is 15-i because i original built it backwards like a fucking idiot
                    platforms.push({p: platform, s: 15-i, o: stepOffset, branch: branchID, sound: 'tick', orientation: '-z'});
                    reorderedPlatforms.push(false);
                    platformsEntity.appendChild(platform);
                }
                //lets make it look cooler for the 0 platform/also easier! 
                platforms[0].p.setAttribute('width', platformSize*3);
                platforms[0].p.setAttribute('depth', platformSize*3);
                //Create the first playhead for platforms
                let playhead = document.createElement('a-box');
                playhead.setAttribute('class', "playheads");
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                playhead.setAttribute('side', 'double');
                playhead.setAttribute('position', {x:0, y: platformSize+0.01, z: 0});
                playhead.setAttribute('width', platformSize-0.1);
                playhead.setAttribute("height", platformSize-0.1);
                playhead.setAttribute("depth", platformSize-0.1);
                playhead.setAttribute("box-collider", ''); 
                playheads.push({p: playhead, o: '-z',startX: 0 , startZ: 0, modDel: 0, modmult: 1});
                platformsEntity.appendChild(playhead);

                //create the first collectable
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('position', {x: 0, y: platformSize, z: -platformSize*(stepSequenceLength-1)});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', platformSize / 6);
                collectable.setAttribute("height", platformSize / 6);
                collectable.setAttribute("depth", platformSize / 6);
                collectable.setAttribute("box-collider", '');
                collectables.push(collectable);
                platformsEntity.appendChild(collectable);  
                onNewEntityAdded(collectable);
            };
            startup();
            //append the platform with everything a single platform needs
            scene.appendChild(platformsEntity);
            //don't run script until we have a scene!
            if (scene.hasLoaded) {
                run();
            } else {
                scene.addEventListener('loaded', run);
            }

            let rightController = document.querySelector('#right-controller');
            let leftController = document.querySelector('#left-controller');

            //right controller
            //             rightController.addEventListener('abuttondown', function(evt) { handleButtonPress(evt); });
            //             //rightController.addEventListener('abuttonup', function(evt) {  });
            //             rightController.addEventListener('bbuttondown', function(evt) { destroyStep = true; handleButtonPress(evt); });
            //             rightController.addEventListener('bbuttonup', function(evt) { destroyStep = false; });
            //             rightController.addEventListener('righttriggerdown', function(evt) { snareTrigger = true; ins = 1; handleButtonPress(evt); });
            //             rightController.addEventListener('righttriggerup', function(evt) { snareTrigger = false; ins = -1; });
            //             rightController.addEventListener('rightgripdown', function(evt) { bellTrigger = true; ins = 3; handleButtonPress(evt);});
            //             rightController.addEventListener('rightgripup', function(evt) { bellTrigger = false; ins = -1; });

            //             //left controller
            //             leftController.addEventListener('xbuttondown', function(evt) { handleButtonPress(evt); });
            //             //leftController.addEventListener('xbuttonup', function(evt) {  });
            //             leftController.addEventListener('ybuttondown', function(evt) { destroyStep = true; handleButtonPress(evt); });
            //             leftController.addEventListener('ybuttonup', function(evt) { destroyStep = false; });
            //             leftController.addEventListener('lefttriggerdown', function(evt) { kickTrigger = true; ins = 0; handleButtonPress(evt); });
            //             leftController.addEventListener('lefttriggerup', function(evt) { ins = -1; kickTrigger = false; });
            //             leftController.addEventListener('leftgripdown', function(evt) { hihatTrigger = true; ins = 2; handleButtonPress(evt); });
            //             leftController.addEventListener('leftgripup', function(evt) { hihatTrigger = false; ins = -1 });
            //first button presson only
            function handleButtonPress(evt) {
                if (soundUP == false) {                 
                    playSomething(); 
                    soundUP = true;
                }
            }    
            document.addEventListener("keydown", function(event) {
                if(event.key == '1'){
                    ins = 0;
                    kickTrigger = true;
                }
                if(event.key == '2'){
                    ins = 1;
                    snareTrigger = true;
                }
                if(event.key == '3'){
                    hihatTrigger = true;
                }
                if(event.key == '4'){
                    bellTrigger = true;
                }
                if(event.key == 'q' || event.key == 'Q'){
                    destroyStep = true;
                    console.log("Q is pressed");
                }     
                keyPressed = event.key;
            });
            //inputs key up
            document.addEventListener("keyup", function(event) {
                if(event.key == '1'){
                    ins = -1;
                    kickTrigger = false;
                }
                if(event.key == '2'){
                    ins = -1;
                    snareTrigger = false;
                }
                if(event.key == '3'){
                    hihatTrigger = false;
                }
                if(event.key == '4'){
                    bellTrigger = false;
                }
                if(event.key == 'q' || event.key == 'Q'){
                    destroyStep = false;
                } 
                keyPressed = event.key;
            });

            //have we collected collectable? 
            function logCollected(event) {
                const collectable = document.getElementById('collectable');
                collectableCount += 1;
                collectablesFound += 1;
                collectablePicked = true;
                for(let i = 0; i < collectables.length; i++){   
                    collectables.splice(i,1);
                    platformsEntity.removeChild(collectable);
                }
            };
            function setupEventListener(entity) {
                // Remove any old event listeners
                entity.removeEventListener('collected', logCollected);
                // Add a new event listener
                entity.addEventListener('collected', logCollected);
            };
            document.addEventListener('DOMContentLoaded', () => {
                const entity = document.querySelector('#collectable');
                setupEventListener(entity);
            });
            //add event listener for new collectable
            function onNewEntityAdded(entity) {
                setupEventListener(entity);
            };
            //check if we're jump and overground for collectible use
            document.addEventListener('DOMContentLoaded', function() {
                let player = document.querySelector('#player');
                player.addEventListener('state-changed', function(event) {
                    isJumping = event.detail.isJumping;
                    isOverGround = event.detail.isOverGround;
                });
            });
            //playhead collision
            document.addEventListener('DOMContentLoaded', function () {
                //get the scene
                const scene = document.querySelector('a-scene');
                //event listener for the 'bonked' event
                scene.addEventListener('bonked', function (event) {
                    hasBonked = true;
                });
                scene.addEventListener('hasEnded', function (event){
                    // use the boolean value as needed
                    hasEnded = true;
                })
            });
            //which direction are we facing
            function headingDirection(player) {
                const rotation = player.getAttribute("rotation");
                let heading = rotation.y;
                //normalize direction
                heading = (heading + 360000) % 360;

                let facing = "";
                if (heading >= 0 && heading <= 45 || heading > 315 && heading < 360) {
                    facing = "northWest";
                } else if (heading > 45 && heading <= 90) {
                    facing = "westNorth";
                } else if (heading > 90 && heading <= 135) {
                    facing = "westSouth";
                } else if (heading > 135 && heading <= 180) {
                    facing = "southWest";
                } else if (heading > 180 && heading <= 225) {
                    facing = "southEast";
                } else if (heading > 225 && heading <= 270) {
                    facing = "eastSouth";
                } else if (heading > 270 && heading <= 315) {
                    facing = "eastNorth";
                }
                return facing;
            };   
            //spend collectables (to generate platforms)
            function useCollectables(player, facing, inputs) {
                const playerPos = player.getAttribute('position');

                if (collectableCount <= 0 || isOverGround !== true || isJumping === true) {
                    return;
                }
                const validInputs = [0, 1, 2, 3];
                if (!validInputs.includes(inputs)) {
                    return;
                }
                const directions = {
                    northWest: { x: '-x', z: '-z' },
                    westNorth: { x: '-x', z: '-z' },
                    westSouth: { x: '-x', z: 'z' },
                    southWest: { x: '-x', z: 'z' },
                    southEast: { x: 'x', z: 'z' },
                    eastSouth: { x: 'x', z: 'z' },
                    eastNorth: { x: 'x', z: '-z' },
                    northEast: { x: 'x', z: '-z' },
                };
                const direction = directions[facing];

                if (!direction) {
                    return;
                }

                let newOrientation;
                if (previousOrientation === 'z' || previousOrientation === '-z') {
                    newOrientation = (direction.x === 'x' || direction.x === '-x') ? direction.x : direction.z;
                } else {
                    newOrientation = (direction.z === 'z' || direction.z === '-z') ? direction.z : direction.x;
                }
                generatePlatforms(playerPos, stepSequenceLength, inputs, newOrientation);
                previousOrientation = newOrientation;
            };
            //we move this shit
            function movePlayheads() {
                const reverseOffset = (stepSequenceLength-0.5) * platformSize;

                for (let i = 0; i < playheads.length; i++) {
                    let modMetro = -(metro - playheads[i].modDel) % stepSequenceLength;

                    const playheadPos = playheads[i].p.getAttribute('position');
                    const playheadSize = parseFloat(playheads[i].p.getAttribute('width'));

                    let normalisedStart, difference, newPosition;

                    if (playheads[i].o == "-z" || playheads[i].o == "z") {
                        normalisedStart = (Math.abs(playheads[i].startX) / platformSize);
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newZ = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheadPos.x,
                            y: playheadPos.y,
                            z: playheads[i].o == "-z"
                            ? playheads[i].startZ + newZ - reverseOffset
                            : playheads[i].startZ - newZ + reverseOffset
                        };
                    } else {
                        normalisedStart = (Math.abs(playheads[i].startZ) / platformSize) % stepSequenceLength;
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newX = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheads[i].o == "-x"
                            ? playheads[i].startX + newX - reverseOffset
                            : playheads[i].startX - newX + reverseOffset,
                            y: playheadPos.y,
                            z: playheadPos.z
                        };
                    }
                    playheads[i].p.setAttribute('position', newPosition);
                }
            };   
            function generatePlatforms(playerPos, numSteps, inputs, orientation){
                //make sure we turn off our collectable
                collectableCount--;
                difficultyMapper();

                //floor playerX and Z so we don't prematurely slide off of platform edge
                let playerFlooredX = Math.floor(0.5+(playerPos.x)/platformSize)*platformSize;
                let playerFlooredZ = Math.floor(0.5+(playerPos.z)/platformSize)*platformSize;

                //update the offset for our step sequencer based on what platform we are over when we generate new ones. 
                stepOffset = ((stepOffset + stepCheck)%16);
                //increment placementID - this is used so we can keep track of which platforms relate to which placement (useful for deletion)
                branchID = branchID + 1;

                //change colour of platforms based on input type
                r = 255;
                g = 255;
                b = 255;

                let platformLabel;

                switch (inputs) {
                    case 0:
                        platformLabel = 'kicks';
                        r = 255;
                        g = 165;
                        b = 0;
                        break;
                    case 1:
                        platformLabel = 'snares';
                        r = 255;
                        g = 210;
                        b = 128;
                        break;
                    case 2:
                        platformLabel = 'hihats';
                        r = 0;
                        g = 191;
                        b = 123;
                        break;
                    case 3:
                        platformLabel = 'bells';
                        r = 0;
                        g = 255;
                        b = 165;
                        break;
                    default:
                        break;
                }
                //generate our platform floor 
                for(let i = numSteps-1; i >= 0; i--){
                    let platform = document.createElement('a-box');
                    platform.setAttribute('class', 'ground');
                    platform.setAttribute('id', 'platform' );
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute('scale',  {x: 1, y: 1, z: 1});
                    platform.setAttribute('box-collider', '');
                    //colour the new platforms with a sick fade yo
                    calcR = r-Math.round(Math.abs((r/numSteps) *(i%numSteps)));
                    calcG = g-Math.round(Math.abs((g/numSteps) *(i%numSteps)));
                    calcB = b-Math.round(Math.abs((b/numSteps) *(i%numSteps)));; 
                    let rgbString = `rgb(${calcR}, ${calcG}, ${calcB})`;
                    platform.setAttribute('color', rgbString);  

                    //set position based on player orientation
                    if(orientation == '-x'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX -(i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            } else {
                                platform.setAttribute('position', {x: playerFlooredX +(-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        } else {
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX -(i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            } else {
                                platform.setAttribute('position', {x: playerFlooredX +(-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                    } 
                    else if(orientation == '-z'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX < 0){
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            } else {
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }
                        } else  {
                            if(playerFlooredX <=0){
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }else {
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }
                        }
                    }
                    else if(orientation == 'z'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX <0){
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            } else {
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            }
                        } else {
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ - (-i *platformSize)});
                            } else{
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            }
                        }
                    }
                    else if(orientation == 'x'){
                        if(playerFlooredZ <= 0){
                            if(playerFlooredX < 0){
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }else {
                                platform.setAttribute('position', {x: playerFlooredX - (-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                        else{
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});

                            } else{
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                    }
                    platforms.push({p:platform, s: 15-i, o: 0, branch: branchID, sound: platformLabel, orient: orientation});

                    platformsEntity.appendChild(platform);
                }
                //playhead biz
                let playhead = document.createElement('a-entity');
                playhead.SetAttribute('id', 'playhead');
                console.log(playhead.getAttribute('id');




                // Use a lil bit of rng to spice up the chance
                let rng = Math.random();

                // Determine the playhead type based on the sequenceOrder
                let playheadType;
                if (sequenceOrder[sequenceOrder.length - 1] === 0) {
                    playheadType = 'kick-playhead';
                } else if (sequenceOrder[sequenceOrder.length - 1] === 1) {
                    playheadType = 'snare-playhead';
                } else if (sequenceOrder[sequenceOrder.length - 1] === 2) {
                    playheadType = 'hihat-playhead';
                } else {
                    playheadType = 'bell-playhead';
                }

                // Apply the appropriate mixin based on the playhead type
                playhead.setAttribute(playheadType, {});
                playhead.setAttribute('class', 'playheads');
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute("box-collider", ''); 

                let newPosition = {x: playerFlooredX, y: playerPos.y + platformSize + 0.001, z: playerFlooredZ};
                playhead.setAttribute('position', newPosition);
                // Store playhead data if needed
                let playheadData = {
                    p: playhead,
                    o: orientation,
                    startX: playerFlooredX,
                    startZ: playerFlooredZ,
                    modDel: stepOffset - currentPlayerStep,
                };
                playheads.push(playheadData);

                // Append the playhead entity to the platformsEntity
                platformsEntity.appendChild(playhead);

                //generate the collectable for that platform
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', platformSize/6);
                collectable.setAttribute("height", platformSize/6);
                collectable.setAttribute("depth", platformSize/6);
                collectable.setAttribute("box-collider", '');

                //quick and dirty as main way is fucked/too computational expensive
                let away = stepSequenceLength-((difficulty/collectablesFound+1)%9)-1;

                if(orientation == '-x'){
                    //ofset the x by the negative of sequence so it places it at the end
                    collectable.setAttribute('position', {x: playerFlooredX -((away)*platformSize), y: platformSize+playerPos.y, z:playerFlooredZ});
                }
                else if(orientation == '-z'){      
                    collectable.setAttribute('position', {x: playerFlooredX, y: platformSize+playerPos.y, z:playerFlooredZ-((away)*platformSize)});
                }
                else if(orientation == 'z'){
                    collectable.setAttribute('position', {x: playerFlooredX, y: platformSize+playerPos.y, z:playerFlooredZ+((away)*platformSize)});
                }
                else if(orientation == 'x'){
                    collectable.setAttribute('position', {x: playerFlooredX +((away)*platformSize), y: platformSize+playerPos.y, z:playerFlooredZ});
                }
                collectables.push(collectable);
                //append to entity in scene
                platformsEntity.appendChild(collectable);
                onNewEntityAdded(collectable);

                //replace our player so they don't get stuck inside the new dropped platform
                player.setAttribute('position', {x: playerPos.x, y: playerPos.y + (platformSize*3)+0.1, z: playerPos.z});

            };
            // use step check and inputs to trigger sound / add them to instrument array 
            function stepSequencer() {
                const playerPos = player.getAttribute('position');
                const playerX = playerPos.x;
                const playerY = playerPos.y;
                const playerZ = playerPos.z;
                const halfPlatformSize = platformSize / 2;

                for (let i = 0; i < platforms.length; i++) {
                    const platformPos = platforms[i].p.getAttribute('position');
                    const platformX = platformPos.x;
                    const platformY = platformPos.y;
                    const platformZ = platformPos.z;

                    if (
                        playerX > platformX - halfPlatformSize &&
                        playerX < platformX + halfPlatformSize &&
                        playerY >= platformY &&
                        playerY <= platformY + (platformSize + 1.1) &&
                        playerZ > platformZ - halfPlatformSize &&
                        playerZ < platformZ + halfPlatformSize
                    ) {
                        let standingStep = (platforms[i].s + platforms[i].o) % stepSequenceLength;
                        stepCheck = platforms[i].s;
                        currentPlayerStep = standingStep;
                        currentBranch = platforms[i].branch;

                        if (collectableCount > 0) {
                            const triggerInfo = [
                                { trigger: kickTrigger, index: 0, setFalse: () => kickTrigger = false },
                                { trigger: snareTrigger, index: 1, setFalse: () => snareTrigger = false },
                                { trigger: hihatTrigger, index: 2, setFalse: () => hihatTrigger = false },
                                { trigger: bellTrigger, index: 3, setFalse: () => bellTrigger = false },
                            ];

                            for (const info of triggerInfo) {
                                if (info.trigger) {
                                    myDrumSequence.push({ p: info.index, s: standingStep, v: 127 });
                                    sampler.setSequence(myDrumSequence, 4);
                                    sequenceOrder.push(info.index);
                                    playerSteps.push(currentPlayerStep);
                                    selector = info.index;
                                    info.setFalse();
                                }
                            }
                        }
                    }
                }
            };      
            //grab our sample triggers and store them as bools to do stuff with 
            function sequenceTracker(myDrumSequence) {
                for (let i = 0; i < myDrumSequence.length; i++) {
                    const drumItem = myDrumSequence[i];
                    const drumIndex = drumItem.s;

                    if (drumItem.v > 0) {
                        switch (drumItem.p) {
                            case 0:
                                kicks[drumIndex] = true;
                                break;
                            case 1:
                                snares[drumIndex] = true;
                                break;
                            case 2:
                                hihats[drumIndex] = true;
                                break;
                            case 3:
                                bells[drumIndex] = true;
                                break;
                        }
                    }
                }
            };
            //mapped our beats so we can check their distribution
            function mappedBar(bar) {
                //steps mapped
                const stepValues = bar.map((bool, index) => {
                    const mapping = [8, 1, 4, 2];
                    const mappingIndex = index % 4;
                    return bool ? mapping[mappingIndex] : 0;
                });
                // Beat values
                const beatValues = [];
                for (let i = 0; i < stepValues.length; i += 4) {
                    let sum = 0;
                    for (let j = i; j < i + 4; j++) {
                        sum += isNaN(stepValues[j]) ? 0 : stepValues[j];
                    }
                    beatValues.push(sum);
                }           
                return {stepValues, beatValues};
            }; 
            //nifty function for checking individual bar distribution
            function barCheck(beats){
                if(beats[0] > beats[1] && beats[2] & beats[3]){
                    return 5;
                }
                if(beats[1] > beats[0]&& beats[2] && beats[3]){
                    return 10;
                }
                if(beats[2] > beats[0]&& beats[1] && beats[3]){
                    return 5;
                }
                if(beats[3] > beats[0]&& beats[1] && beats[2]){
                    return 5;
                }  else {
                    return 0;
                } 
            };
            //lil scale
            function scale (number, inMin, inMax, outMin, outMax) {
                return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
            };      
            //move our collectables around the steps environment based on step distribution
            function difficultyMapper(){
                //mapped bar returns 16 step Values mapped to 8, 1, 4, 2
                let mappedKicks = mappedBar(kicks);
                let mappedSnares = mappedBar(snares);
                let mappedHihats = mappedBar(hihats);
                let mappedBells = mappedBar(bells);
                let allKicksStepValues = mappedBar(kicks).stepValues;
                let allSnaresStepValues = mappedBar(snares).stepValues;
                let allHihatsStepValues = mappedBar(hihats).stepValues;
                let allBellsStepValues = mappedBar(bells).stepValues;
                let allKicksBeatValues = mappedBar(kicks).beatValues;
                let allSnaresBeatValues = mappedBar(snares).beatValues;
                let allHihatsBeatValues = mappedBar(hihats).beatValues;
                let allBellsBeatValues = mappedBar(bells).beatValues;
                //our distances so we know where we're mapping notes too
                let sumKicks = 0;
                let sumSnares = 0;
                let sumHihats = 0;
                let sumBells = 0;
                let sumAllSteps =[];
                //where to play then next collectable
                let collectablePlacement;
                //get sums of all our steps
                for(let i = 0; i < 16; i++){
                    sumKicks += allKicksStepValues[i];
                    sumSnares += allSnaresStepValues[i];
                    sumHihats += allHihatsStepValues[i];
                    sumBells += allBellsStepValues[i];
                    sumAllSteps.push(allKicksStepValues[i]+allSnaresStepValues[i]+allHihatsStepValues[i]+allBellsStepValues[i]);
                }
                //increase difficulty abit every collection
                for(let i = 0; i < collectablesFound; i++){
                    difficulty += 5;
                }
                //increase difficult based on kicks
                if(sumKicks > 12 && sumKicks <=18){
                    difficulty +=25;
                }
                //increase difficulty based on snares
                if(sumSnares > 12  && sumSnares <= 16 ){
                    difficulty +=25;
                } 
                else if (sumSnares > 16){
                    difficulty +=30;
                }
                //increase difficult based on hihats and bells
                if(sumHihats + sumBells > 20){
                    difficulty +=15;
                }
                //reward players if they can manage some parity between distributions
                if(allKicksBeatValues[0] > 0 && allKicksBeatValues[0] == allKicksBeatValues[1] && allKicksBeatValues[2] && allKicksBeatValues[3]){
                    difficulty -=15;
                } 
                if(allHihatsBeatValues[0] > 0 && allHihatsBeatValues[0] == allHihatsBeatValues[1] && allHihatsBeatValues[2] && allHihatsBeatValues[3] || allBellsBeatValues[0] > 0 && allBellsBeatValues[0] == allBellsBeatValues[1] && allBellsBeatValues[2] && allBellsBeatValues[3]){
                    difficulty -=20;
                }
                //when distribution is too lopsided make target location very far way. 
                difficulty = difficulty + barCheck(sumAllSteps);

            };

            //get the shuffled orderd for our new platform layer
            function reorderSamples(sample, currentPlayerStep) {
                const reordered = [];
                for (let i = 0; i < 16; i++) {
                    reordered[i] = sample[(currentPlayerStep + 1 +  i) % 16];
                }
                return reordered;
            };      
            //helper to minimise setAttributes
            function updatePlatformAttributes(platform, width, height, depth) {
                platform.p.setAttribute('width', width);
                platform.p.setAttribute('height', height);
                platform.p.setAttribute('depth', depth);
                platform.p.setAttribute('scale', { x: 1, y: 0.98, z: 1 });
            };
            //update our platforms when we trigger the corresponding step yo
            function updatePlatforms() {
                let base = playerSteps.length * 16;
                let reorderedSamples;

                switch (selector) {
                    case 0:
                        reorderedSamples = reorderSamples(kicks, currentPlayerStep);
                        break;
                    case 1:
                        reorderedSamples = reorderSamples(snares, currentPlayerStep);
                        break;
                    case 2:
                        reorderedSamples = reorderSamples(hihats, currentPlayerStep);
                        break;
                    case 3:
                        reorderedSamples = reorderSamples(bells, currentPlayerStep);
                        break;
                    default:
                        return;
                }
                for (let i = 0; i < reorderedSamples.length; i++) {
                    if (reorderedSamples[i] === true) {

                        let platform = platforms[i + base];
                        switch (selector) {
                            case 0:
                                updatePlatformAttributes(platform, platformSize * 3, platformSize, platformSize * 3);
                                break;
                            case 1:
                                let width = (platform.orient == 'x' || platform.orient == '-x') ? platformSize * 2 : platformSize / 2;
                                let depth = (platform.orient == 'x' || platform.orient == '-x') ? platformSize / 2 : platformSize * 2;
                                updatePlatformAttributes(platform, width, platformSize * 3, depth);
                                break;
                            case 2:
                                let hatWidth = (platform.orient == 'x' || platform.orient == '-x') ? platformSize * 3 : platformSize / 2;
                                let hatDepth = (platform.orient == 'x' || platform.orient == '-x') ? platformSize / 2 : platformSize * 3;
                                updatePlatformAttributes(platform, hatWidth, platformSize / 4, hatDepth);
                                break;
                            case 3:
                                updatePlatformAttributes(platform, platformSize * 3, platformSize/4, platformSize * 3);
                                break;
                        }
                    }
                }
                selector = -1;
            };
            //destroy our playforms if our players want to do that
            function destroyer(){
                const collectable = document.getElementById('collectable');
                if(destroyStep == true && currentBranch > 0){
                    for (let i = platforms.length - 1; i >= 0; i--) {
                        if (platforms[i].branch === currentBranch) {
                            platforms[i].p.remove();
                            platforms.splice(i, 1); 
                        }
                    }
                    collectableCount+=1;
                    playerSteps.splice(0,1);
                    platformsEntity.remove(collectable);
                    destroyStep = false;
                }
            };
            //this is where the real magic happens
            function updateSounds(){
                //have we been bonked by a playhead
                if(hasBonked == true){
                    let randomNote = notes[Math.floor(Math.random()*notes.length)];
                    enemySynth.noteon(randomNote, 127);
                    bonking = 1.0;
                    roomSize =1.0;
                    hasBonked = false;
                    pauseBonk = true;
                }
                if(bonking > 0){
                    bonking -= 0.1;
                    //reverb += 0.2;
                    //enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                }
                if (bonking  <= 0){
                    hasBonked = false;
                    if(pauseBonk){
                        enemySynth.noteoff(62);
                        enemySynth.noteoff(64);
                        enemySynth.noteoff(65);
                        enemySynth.noteoff(69);
                    }
                    bonking = 0;
                    //enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                } 

                //jump sounds
                if(isJumping == true){
                    filter += 0.5;  
                    backingMidSynth.setParam("lfoFrequency", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                    bassSynth.setParam("cutoff", filter *40);
                    sampler.setParam("rate_1", scale(filter, -2, 1, 0.1, 0.5)) ;
                    sampler.setParam("rate_2", filter+0.5);
                    sampler.setParam("rate_3", filter-0.5);
                } else {
                    if(filter > 0.11){
                        backingMidSynth.setParam("lfoFrequency", filter);
                        backingMidSynth.setParam("lfoPitchMod", filter);
                        backingMidSynth.setParam("lfoPitchMod", filter);  
                    }
                    filter = 0;
                } 
                //falling sounds
                let fall = player.getAttribute('position').y;
                if(fall < -2){
                    let drop = scale(fall,-30,0, 0.5, 0.1);
                    sampler.setParam("rate_0", drop);
                    sampler.setParam("rate_1", drop);
                    bassSynth.setParam("adsrPitchMod", drop*-1000);
                    bassSynth.setParam('cutoff', drop*-100);
                    bassSynth.setParam("lfoFrequency", 10-drop);
                    backingMidSynth.setParam("lfoFrequency", drop);
                    sampler.setParam("rate_4", drop);
                } 
                if(fall <= -70){
                    sampler.setParam("rate_0", 0.5);
                    sampler.setParam("rate_1", 0.5);
                    bassSynth.setParam("adsrPitchMod", 0);
                    //backingMidSynth.setParam("reverbMix", 0.12);
                }

                //our arrangement for backing synths
                if(collectablesFound == 1 && collectablePicked == true){

                    bassSynth.setParam('gain', 1);
                    collectablePicked = false;

                }
                if(collectablesFound == 2 && collectablePicked == true){   
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;                        
                    }                    
                }
                if(collectablesFound == 3 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38},{s:4, l:4, p:36},{s:8, l:4, p:33}, {s:12, l:4, p:36}],2);
                        bassSynth.setLoop(16,4);
                        collectablePicked = false;    
                    }   
                }
                if(collectablesFound == 4 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind(); 
                        bassSynth.setSequence([{s:0, l:16, p:33}],1);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    }   
                }
                if(collectablesFound == 5 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38}, {s:0, l:16, p:48}],4);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    } 
                }
                if(collectablesFound == 6 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:8, p:38},{s:8, l:4, p:48},{s:12, l:4, p:45}, {s:16, l:16, p:39}],4);
                        bassSynth.setLoop(32,4);
                        backingMidSynth.setSequence([{s:0, l:8, p:a7sus4},
                                                     {s:16, l:8, p:cadd9},
                                                    ],4);
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;    
                    } 
                }
                if(collectablesFound == 7 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:16, p:38}],1);
                        bassSynth.setLoop(32,4);
                        collectablePicked = false;    
                    }
                }
            }; 
            //end game reset
            function end(){
                //sequentially do stuff
                if (eventFixer !== lastEventFixer) {
                    lastEventFixer = eventFixer;
                    eventChangeCounter+=0.5;
                }
                if (eventChangeCounter % 5 === 2) { 
                    scene.setAttribute('background',{color: 'black'});
                } 
                else if (eventChangeCounter % 5 === 3) {
                    killplane.setAttribute('color', 'black' );
                    for(let i = 0; i < platforms.length; i++){
                        platforms[i].p.remove();
                        platforms.splice(i, 1);
                    }
                    collectables.splice(0, collectables.length);
                    platformsEntity.remove(collectable);
                } 
                else if (eventChangeCounter % 5 === 4) {
                    star.setAttribute('color', 'Black');
                    sampler.mute();
                    backingMidSynth.mute();
                    bassSynth.mute();
                    instruments.playPause();
                    instruments.rewind();
                } 
                else if (eventChangeCounter % 5 === 0 && eventChangeCounter !== 0) {
                    canStart = true;
                    hasEnded = false;
                }
            };
            //we pushin' speakers 
            const playSomething=()=>{
                instruments.loadModules().then(()=> {

                    enemySynth = instruments.addSynth();
                    backingMidSynth = instruments.addSynth();
                    bassSynth = instruments.addSynth();
                    backingMidSynth.setOsc(1);
                    bassSynth.setOsc(1);
                    enemySynth.setOsc(1);

                    backingMidSynth.setParams([
                        ["oscFn",3],
                        ["lfoOscFn",0],
                        ["gain",0.4],
                        ["pan",0.5],
                        ["attack",165],
                        ["decay",330],
                        ["sustain",0.58],
                        ["release",495],
                        ["lfoFrequency",0.7],
                        ["lfoPitchMod",0],
                        ["lfoFilterMod",1000],
                        ["lfoAmpMod",0.68],
                        ["adsrPitchMod",1],
                        ["cutoff",957.6],
                        ["reverbMix",0.33],
                        ["roomSize",0.27],
                        ["delay",0],
                        ["delayMix",0.35],
                        ["frequency",440],
                        ["frequency2",220],
                    ]);
                    enemySynth.setParams([
                        ["oscFn",3],
                        ["lfoOscFn",1],
                        ["gain",2],
                        ["pan",0.5],
                        ["attack",0],
                        ["decay",330],
                        ["sustain",0.1],
                        ["release",1500],
                        ["lfoFrequency",6.3],
                        ["lfoPitchMod",0],
                        ["lfoFilterMod",220],
                        ["lfoAmpMod",0.88],
                        ["adsrPitchMod",0],
                        ["cutoff",1372],
                        ["reverbMix",0.12],
                        ["roomSize",0.5],
                        ["delay",0],
                        ["delayMix",0],
                        ["frequency",440],
                        ["frequency2",220],
                    ]);
                    bassSynth.setParams([
                        ["oscFn",3],
                        ["lfoOscFn",1],
                        ["gain",0],
                        ["pan",0.53],
                        ["attack",1155],
                        ["decay",480],
                        ["sustain",0.58],
                        ["release",1185],
                        ["lfoFrequency",10],
                        ["lfoPitchMod",0],
                        ["lfoFilterMod",1000],
                        ["lfoAmpMod",0.78],
                        ["adsrPitchMod",1],
                        ["cutoff",40],
                        ["reverbMix",0],
                        ["roomSize",0],
                        ["delay",0],
                        ["delayMix",0.35],
                        ["frequency",440],
                        ["frequency2",220],
                    ]);

                    enemySynth.mapped = ["gain","reverbMix","roomSize", "delay","delayMix"];
                    backingMidSynth.mapped = ["gain", "lfoFrequency", "lfoPitchMod", "reverb"];
                    bassSynth.mapped = ["lfoFrequency", "pan", "cutoff" ,"adsrPitchMod", "frequency"];

                    sampler = instruments.addSampler();
                    sampler.loadSample("BD-ER1-CR8000ish.wav", 0);
                    sampler.loadSample("DR660SnareLofinice.wav", 1);
                    sampler.loadSample("TOM-ER-MicroTom2.wav", 2);
                    sampler.loadSample("FX-ER-Sonario.wav", 3);
                    sampler.loadSample("FX-ER1-Woodzblox.wav", 4);

                    sampler.setParam("rate_0", 1);
                    sampler.setParam("rate_1", 1);
                    sampler.setParam("rate_2", 1);
                    sampler.setParam("rate_3", 1);
                    sampler.setParam("rate_4", 1);
                    sampler.setParam("pan_0", 0.5);
                    sampler.setParam("pan_1", 0.5);
                    sampler.setParam("pan_2", 0.5);
                    sampler.setParam("pan_3", 0.5);
                    sampler.setParam("pan_4", 0.5);
                    sampler.setParam("gain_0", 1);
                    sampler.setParam("gain_1", 1);
                    sampler.setParam("gain_2", 1);    
                    sampler.setParam("gain_3", 1);    
                    sampler.setParam("gain_4", 1);  

                    sampler.mapped = ["rate_0", "rate_1", "rate_2", "rate_3", "rate_4"];


                    instruments.playPause();
                    instruments.setTempo(tempo);
                    sampler.setSequence(myDrumSequence, 4);

                    //Sequence and loop set at 4 ticks per beat (1/16ths)
                    backingMidSynth.setSequence(midSynthSeq, 4);
                    bassSynth.setSequence(bassSynthSeq, 4);
                    backingMidSynth.setLoop(16,4);
                    bassSynth.setLoop(16,4);
                    sampler.setLoop(16,4);
                    instruments.playPause();

                    instruments.setOnTick((playHeads)=> {
                        //The current playhead of the third instrument added
                        if(playHeads[2] % 6 == 4) {
                            metro+=0.5;
                            metro++;
                        }

                        if(playHeads[2] % 48 == 4) {
                            sequenceTrigger = true;
                            eventFixer++;
                        } 
                    });
                }).catch((err)=> {
                    //console.log("error", err);
                });
            };
            //start the step sequencer
            document.addEventListener('keydown', (event) => {
                if (event.key && soundUP == false){
                    playSomething();;
                    soundUP = true; 
                }
            });

            setInterval(run, 50);
            function run() {
                if (soundUP) {
                    movePlayheads();
                    stepSequencer(); 
                    useCollectables(player, headingDirection(player), ins);
                    sequenceTracker(myDrumSequence);
                    updatePlatforms();
                    updateSounds();
                    destroyer();

                }
                if(hasEnded == true){
                    end();
                }
                if(canStart == true ){
                    playerStep = [];
                    star.setAttribute('color', 'white');
                    player.setAttribute('position', {x:0, y: 2, z:8});
                    scene.setAttribute('background', {color: 'white'});
                    killplane.setAttribute('color', 'red');
                    startup();
                    scene.appendChild(platformsEntity);
                    collectableCount = 0;
                    collectablesFound = 0;
                    collectablePicked = false;
                    instruments.setTempo(172);
                    sampler.setParams([["gain_0", 1],["gain_1", 1],["gain_2", 1],["gain_3", 1] ]);
                    bassSynth.setParam('gain', 0);
                    backingMidSynth.setParam('gain', 1);
                    backingMidSynth.setSequence(midSynthSeq, 2);
                    bassSynth.setSequence(bassSynthSeq2, 4);
                    instruments.rewind();
                    backingMidSynth.setLoop(16,4);
                    bassSynth.setLoop(64,4);
                    sampler.setLoop(64,4);
                    sampler.unmute();
                    backingMidSynth.unmute();
                    bassSynth.unmute();
                }
            } 
        </script>
    </body>
</html> 

