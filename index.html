<html>
    <head>
          <script src="./enable-threads.js"></script>
  <script crossorigin src = "./maxiInstruments.v.0.7.1.js"></script>
        <script src="dist/aframe-master.min.js"></script>
        <!--        JUMP AND FALL (BUT NEVER DEATH, STUCK IN THIS ETERNAL LOOP FOREVER. FOREVAAAAAAAAA)-->
        <script>AFRAME.registerComponent('jump', {
                schema: {
                    groundSelector: { type: "string", default: ".ground"},
                },
                init: function () {
                    this.grounds = document.querySelectorAll(this.data.groundSelector);
                    this.isOverGround = true;
                    this.isOnGround = false;
                    this.isJumping = false;
                    this.jumpHeight = 0.40;
                    this.jumpSpeed = this.jumpHeight;
                    this.fallSpeed = 0.5;
                    this.canJump = true;

                    document.querySelector('#leftHand').addEventListener('triggerdown', () => {
                        if (!this.isJumping && this.canJump) {
                            this.isJumping = true;
                            this.jumpSpeed = 0.38;
                            this.isOnGround = false;
                        }
                    });
                    // Handle space key press
                    window.addEventListener('keydown', (event) => {
                        if (event.key === ' ' && !this.isJumping) {
                            if (this.canJump == true) {
                                this.isJumping = true;
                                this.jumpSpeed = this.jumpHeight;
                                this.isOnGround = false;
                            }
                        }
                    });
                },
                tick: function () {
                    const player = document.querySelector('#player');
                    const currentPosition = player.getAttribute('position');
                    this.grounds = document.querySelectorAll(this.data.groundSelector);
                    this.isOverGround;
                    this.isJumping;
                    let lowY, highY;

                    //see if we're over/under any platforms excluding playheads
                    this.groundCheck = Array.from(this.grounds).reduce((result, ground) => {

                        halfGroundX = parseFloat(ground.getAttribute("width") / 2);
                        halfGroundZ = parseFloat(ground.getAttribute("depth") / 2);
                        groundPosition = ground.getAttribute("position");
                        groundY = parseFloat(ground.getAttribute("height"));
                        newYLevel = groundY+groundPosition.y;  

                        const isOverGround = currentPosition.x >= groundPosition.x - halfGroundX &&
                              currentPosition.x <= groundPosition.x + halfGroundX &&
                              currentPosition.z >= groundPosition.z - halfGroundZ &&
                              currentPosition.z <= groundPosition.z + halfGroundZ;

                        if (isOverGround && halfGroundX === result.halfGroundX && halfGroundZ === result.halfGroundZ) {
                            if (ground.id !== "playhead") {
                                if (newYLevel < result.lowY) {
                                    result.lowY = newYLevel;
                                }
                                if (newYLevel > result.highY) {
                                    result.highY = newYLevel;
                                }
                            }
                            return result;
                        } else if (isOverGround) {
                            return {
                                isOverGround: true,
                                groundY: newYLevel,
                                halfGroundX: halfGroundX, 
                                halfGroundZ: halfGroundZ,
                                lowY: newYLevel,
                                highY: (ground.id === "playhead") ? 0 : newYLevel
                            };
                        } else {
                            return result;
                        }
                    }, { isOverGround: false, groundY: 0, halfGroundX: 0, halfGroundZ: 0, lowY: 0, highY: 0 });
                    //console.log("y= ",currentPosition.y, "GY=",this.groundCheck.groundY, "LY=",lowY,"highY",highY);

                    if (!this.isJumping && this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY + 0.1) {
                        this.isOnGround = true;
                    } else {
                        this.isOnGround = false;
                    }
                    if (this.isOnGround && !this.isJumping) {
                        this.canJump = true;
                    }

                    //send our values errrywhere
                    if (this.isJumping !== this.prevIsJumping || this.groundCheck.isOverGround !== this.groundCheck.prevIsOverGround) {
                        this.prevIsJumping = this.isJumping;
                        this.groundCheck.prevIsOverGround = this.groundCheck.isOverGround;
                        this.el.emit('state-changed', {isJumping: this.isJumping, isOverGround: this.groundCheck.isOverGround});
                    }
                    //gotta jump up jump up to get down
                    if (this.isJumping) {

                        this.jumpSpeed -= 0.01;
                        const newY = Math.max(currentPosition.y + this.jumpSpeed,this.groundCheck.lowY);

                        let clamp;
                        if(newY >= this.groundCheck.lowY && newY <= this.groundCheck.highY){
                            this.jumpSpeed -=0.01;
                            clamp = Math.max(newY, this.groundCheck.lowY);  
                        } else 
                            if(newY >= this.groundCheck.highY){
                                clamp = Math.max(newY,this.groundCheck.highY);   
                            }
                        player.setAttribute('position', { x: currentPosition.x, y: clamp, z: currentPosition.z });

                        if (this.jumpSpeed <= -this.fallSpeed) {
                            this.isJumping = false;
                        }
                    } 
                    //so we can land on other platforms jumping from a different height
                    else if(this.groundCheck.isOverGround && currentPosition.y >= this.groundCheck.groundY-0.6|| !this.groundCheck.isOverGround && currentPosition.y > this.groundCheck.lowY){
                        this.jumpSpeed = 0.;
                        let fall = -0.5;

                        if(currentPosition.y >= this.groundCheck.highY){
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.highY);
                            const clamped = Math.max(newY,this.groundCheck.lowY);
                            player.setAttribute('position', { x: currentPosition.x, y: clamped, z: currentPosition.z });
                            this.canJump = true; 
                            this.jumpSpeed = this.jumpHeight;
                        } else {
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.lowY);
                            //const clamped = Math.max(newY,this.groundCheck.lowY);
                            player.setAttribute('position', { x: currentPosition.x, y: newY, z: currentPosition.z });
                            this.canJump = true; 
                            this.jumpSpeed =this.jumpHeight;
                        }
                    }
                    //fall off the edge
                    else if(!this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall;
                        player.setAttribute('position', { x: currentPosition.x, y: newY, z: currentPosition.z });
                        this.canJump = false;
                    }
                    //get rid of the hang if player moves back under ground to trigger is overground bool
                    else if(this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall
                        player.setAttribute('position', { x: currentPosition.x, y: newY, z: currentPosition.z });
                        this.canJump = false;
                    }
                    //reset the player if they fall too far
                    if(currentPosition.y <= -82){
                        //make sure y is platformSize innit
                        player.setAttribute('position', { x: 0, y: 2, z: 8 });
                    }
                },
            });
        </script>
        <!--        COLLIDING BOXES AKA PLATFORMS-->
        <script>AFRAME.registerComponent("box-collider", {

                schema: { 
                    hasBonked: {type: 'boolean', default: false}},
                init: function () {
                    this.player = document.querySelector("#player");
                    this.collected = false;
                    this.hasBonked = false;
                    this.hasEnded = false;
                },
                tick: function () {
                    this.player = document.querySelector("#player");
                    const playerPos = this.player.object3D.position;
                    const playerScale = this.player.getAttribute("scale");
                    const boxPos = this.el.object3D.position;
                    const bosRot = this.el.object3D.rotation;
                    const boxID = this.el.getAttribute("id");
                    const boxScale = this.el.getAttribute("scale");

                    const halfWidthBox = 0.5 * parseFloat(this.el.getAttribute("width"));
                    const halfHeightBox = 0.5 * parseFloat(this.el.getAttribute("height"));
                    const halfDepthBox = 0.5 * parseFloat(this.el.getAttribute("depth"));

                    const halfWidthPlayer = 0.5 * parseFloat(this.player.getAttribute("width"));
                    const halfHeightPlayer = 0.5 * parseFloat(this.player.getAttribute("height"));
                    const halfDepthPlayer = 0.5  * parseFloat(this.player.getAttribute("depth"));

                    //distances
                    const dx = playerPos.x - boxPos.x;
                    const dy = playerPos.y - boxPos.y;
                    const dz = playerPos.z - boxPos.z;
                    //take the right face
                    const overlapX = halfWidthBox + halfWidthPlayer - Math.abs(dx);
                    const overlapY = halfHeightBox + halfHeightPlayer - Math.abs(dy);
                    const overlapZ = halfDepthBox + halfDepthPlayer - Math.abs(dz);                    

                    if (overlapX > 0 && overlapY >= 0 && overlapZ > 0) {
                        const minOverlap = Math.min(overlapX, overlapY, overlapZ);
                        if (minOverlap === overlapX) {
                            if(dx > 0){
                                if(boxID == "platform"){
                                    playerPos.x = boxPos.x + halfWidthBox + halfWidthPlayer;  
                                }
                                else if(boxID == 'playhead'){
                                    playerPos.x = boxPos.x + (halfWidthBox*2) + halfWidthPlayer +3.1;
                                    this.hasBonked = true;
                                    this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });


                                }
                                else if(boxID == "collectable"){
                                    this.collected = true;
                                    this.el.emit('collected', { detail: {collected: this.collected}});
                                }
                            } 
                            else {
                                if(boxID == "platform"){
                                    playerPos.x = boxPos.x - halfWidthBox - halfWidthPlayer ;    }
                                else if(boxID == 'playhead'){
                                    playerPos.x = boxPos.x - (halfWidthBox*2)  - halfWidthPlayer - 3.1;
                                    this.hasBonked = true;  
                                    this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });

                                }
                                else if(boxID == "collectable"){
                                    this.collected = true;
                                    this.el.emit('collected', { detail: {collected: this.collected}});
                                }
                            }
                        } else if (minOverlap === overlapY) {
                            miniOverlap = overlapY;
                            if(dy > 0){
                                if(boxID == "platform"){
                                    playerPos.y = boxPos.y + halfHeightBox+ halfHeightPlayer;
                                }
                                else if(boxID == 'playhead'){
                                    playerPos.y = boxPos.y + halfHeightBox + halfHeightPlayer;
                                    this.hasBonked = true;
                                    this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });
                                }
                                else if(boxID == "collectable"){
                                    this.collected = true;
                                    this.el.emit('collected', { detail: {collected: this.collected}});
                                } 
                                else if(boxID == 'lurker'){
                                    this.hasEnded = true;
                                    this.el.sceneEl.emit('hasEnded', {detail: {hasEnded: this.hasEnded}});
                                    playerPos.y = boxPos.y + halfHeightBox + halfHeightPlayer;

                                }
                            }
                            else {
                                if(boxID == "platform"){
                                    playerPos.y = boxPos.y - halfHeightBox - halfHeightPlayer;
                                }
                                else if(boxID == 'playhead'){
                                    playerPos.y = boxPos.y - halfHeightBox - halfHeightPlayer;
                                    this.hasBonked = true;
                                    this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });
                                }
                                else if(boxID == "collectable"){
                                    this.collected = true;
                                    this.el.emit('collected', { detail: {collected: this.collected}});
                                }else if(boxID == 'lurker'){
                                    this.hasEnded = true;
                                    this.el.sceneEl.emit('hasEnded', {detail: {hasEnded: this.hasEnded}});
                                    playerPos.y = boxPos.y + halfHeightBox + halfHeightPlayer;

                                }
                            }
                        } else if (minOverlap === overlapZ) {
                            if(dz > 0) {
                                if(boxID == "platform"){
                                    playerPos.z = boxPos.z + halfWidthBox + halfDepthPlayer;
                                }
                                else if(boxID == 'playhead'){
                                    playerPos.z = boxPos.z + (halfDepthBox*2) + halfDepthPlayer + 3.1;
                                    this.hasBonked = true;
                                    this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });

                                }
                                else if(boxID == "collectable"){
                                    this.collected = true;
                                    this.el.emit('collected', { detail: {collected: this.collected}});
                                }
                            }
                            else {
                                if(boxID == "platform"){
                                    playerPos.z = boxPos.z - halfDepthBox - halfDepthPlayer;
                                }
                                else if(boxID == 'playhead'){
                                    playerPos.z = boxPos.z - (halfDepthBox*2) - (halfDepthPlayer) - 3.1;
                                    this.hasBonked = true;
                                    this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });

                                }
                                else if(boxID == "collectable"){
                                    this.collected = true;
                                    this.el.emit('collected', { detail: {collected: this.collected}});
                                }
                            }
                        }
                    }
                },
            });</script>
        <!--        WE GOT A LURKER HERE PEOPLE-->
        <script>      AFRAME.registerComponent("lurker", {
                schema: {
                    target: { type: "selector" },
                    easingFactor: { type: "number", default: 0.03 },
                    offset: { type: "number", default: 0 },
                },

                init: function () {
                    // Store the initial Y position
                    this.initialY = this.el.object3D.position.y;
                    // Create a new Vector3 for the target's world position and direction
                    this.targetWorldPosition = new THREE.Vector3();
                    this.offsetVector = new THREE.Vector3();
                },

                tick: function () {
                    // Get the target's world position considering the entire scene hierarchy
                    this.data.target.object3D.getWorldPosition(this.targetWorldPosition);

                    // Get the target's rotation
                    const targetRotation = this.data.target.object3D.rotation;

                    // Calculate the offset position based on the target's rotation
                    this.offsetVector.set(
                        -Math.sin(targetRotation.y) * this.data.offset,
                        0,
                        -Math.cos(targetRotation.y) * this.data.offset
                    );

                    // Apply easing to X and Z positions with the offset
                    this.el.object3D.position.x +=
                        (this.targetWorldPosition.x + this.offsetVector.x - this.el.object3D.position.x) * this.data.easingFactor;
                    this.el.object3D.position.z +=
                        (this.targetWorldPosition.z + this.offsetVector.z - this.el.object3D.position.z) * this.data.easingFactor;

                    // Keep the Y position constant using the stored initial Y value
                    this.el.object3D.position.y = this.initialY;
                },
            });
        </script>
        <div id = "synths"></div>
    </head>
    <body>
                <a-scene background="color: #005AFF">
            <!--vr controller-->
            <a-entity id="leftHand" oculus-touch-controls="hand: left;"></a-entity>
            <a-entity id="rightHand" oculus-touch-controls="hand: right;"></a-entity>

            <!--this is where the magic happens-->
            <a-entity class="ground" id="platformsEntity"></a-entity>
            <!--player/camera-->
            <a-entity id="player" camera position="0 1 8"width="1.0" height="2"depth="1" look-controls wasd-controls="acceleration: 60" jump></a-entity>
            <!--killplane-->
            <a-plane id="killplane" side="double" position="0 -18 0" rotation="-90 0 0" width="500" height="500" color="red"></a-plane>
            <!--start point-->
            <a-box class="ground" id="start" position="0 -0.75 8" width="4" height="1" depth="4" color="white"></a-box>
            <!--end point-->
            <a-box class='end' id="lurker" position="0 42 8" width="9" height="1" depth="9" color="black" box-collider lurker="target: #player "></a-box>

            <!-- ui -->
            <!--
<a-entity id="ui">
<a-text id="text1" value="trigger = jump" position="-0.5 1.5 -1" look-at="#camera" color="white" font-size="0.1"></a-text>
<a-text id="text2" value="y = cowbell" position="-0.5 1.4 -1" look-at="#camera" color="white" font-size="0.1"></a-text>
<a-text id="text3" value="x = kicks" position="-0.5 1.3 -1" look-at="#camera" color="white" font-size="0.1"></a-text>  
<a-text id="text4" value="trigger = jump" position="0.5 1.5 -1" look-at="#camera" color="white" font-size="0.1"></a-text>
<a-text id="text5" value="b = hihats" position="0.5 1.4 -1" look-at="#camera" color="white" font-size="0.1"></a-text>
<a-text id="text6" value="a = snares" position="0.5 1.3 -1" look-at="#camera" color="white" font-size="0.1"></a-text>
</a-entity>
-->
        </a-scene>
        <script>
            let tempo = 96;
            let enemySynth;
            let backingMidSynth;
            let bassSynth;
            let sampler; 
            let staging = 0;
            let soundUP = false;
            //we jammin, and i hope you like jammin too
            var dm79 = [50, 57, 64, 65, 72];
            var eb911 = [51, 58, 65, 67, 69];
            var a7sus4 = [45, 57, 64, 67,47];
            var cadd9 = [48, 62, 64, 67, 72];
            let myDrumSequence = [
                {p:4, s:0, v:10},
                {p:4, s:4, v:20},
                {p:4, s:8, v:40},
                {p:4, s:12, v:60}];


            const instruments = new MaxiInstruments();
            let scene = document.querySelector('a-scene');
            let player= document.getElementById('player');
            let platformsEntity = document.getElementById('platformsEntity');
            let destroyStep = false;
            let platforms = [];
            let reorderedPlatforms =[];
            let playheads = [];
            let collectables = [];
            let stepSequenceLength = 16;
            let stepOffset = 0;
            let stepCheck = 0;
            let branchID = 0;
            let currentBranch = 0;
            let platformSize = 3;
            let previousOrientation = '-z';
            let metro = 0;
            let doubleMetro = 0;
            let collectableCount = 0;
            let collectablesFound = 0;
            let collectablePicked = false;
            let difficulty = 0;
            let eventFixer = 0;
            let movingCollectablesLocations =[];
            let score = 0;
            let keyPressed='';
            let hasEnded = false;
            let canStart = false;
            let isJumping = false;
            let isOverGround = true;
            let currentPlayerStep;
            let kickTrigger = false;
            let snareTrigger = false;
            let hihatTrigger = false;
            let bellTrigger = false;
            let sequenceTrigger = false;
            var selector = -1;
            let sequenceOrder = [-1];
            let playerSteps = [];
            let totalSteps = 0;
            let kicks = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let snares= [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let hihats=[false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let bells = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];

            //things that trigger sound
            let hasBonked = false;
            let bonking = 0;
            //bonk notes
            let notes = [62, 64, 65, 69 ];
            let reverb = 0;
            let roomSize = 0;
            let filter = 0.1;

            //initialise our environment
            function startup(){
                canStart = false;
                //Create the first sequence of platforms
                for(let i = stepSequenceLength-1; i >= 0 ; i--){
                    let platform = document.createElement('a-box');
                    platform.setAttribute('class', 'ground');
                    platform.setAttribute('id', 'platform');
                    let calc = Math.round(Math.abs((255/16) *i));
                    let rgbString = `rgb(${calc}, ${calc}, ${calc})`;
                    platform.setAttribute('material', 'color', rgbString);
                    //platform.setAttribute('material', {color: rgbString, transparent: 'true', opacity: '0.5'});

                    platform.setAttribute('position', {x: 0, y: 0, z: -i*platformSize});
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute('box-collider', '');
                    //step is 15-i because i original built it backwards like a fucking idiot
                    platforms.push({p: platform, s: 15-i, o: stepOffset, branch: branchID, sound: 'tick', orientation: '-z'});
                    reorderedPlatforms.push(false);
                    platformsEntity.appendChild(platform);
                }
                //lets make it look cooler for the 0 platform/also easier! 
                platforms[0].p.setAttribute('width', 9);
                platforms[0].p.setAttribute('depth', 9);
                //Create the first playhead for platforms
                let playhead = document.createElement('a-box');
                playhead.setAttribute('class', "playheads");
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                playhead.setAttribute('side', 'double');
                playhead.setAttribute('position', {x:0, y: platformSize+0.01, z: 0});
                playhead.setAttribute('width', platformSize-0.1);
                playhead.setAttribute("height", platformSize-0.1);
                playhead.setAttribute("depth", platformSize-0.1);
                playhead.setAttribute("box-collider", ''); 
                playheads.push({p: playhead, o: '-z',startX: 0 , startZ: 0, modDel: 0, modmult: 1});
                platformsEntity.appendChild(playhead);

                //create the first collectable
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('position', {x: 0, y: platformSize, z: -platformSize*(stepSequenceLength-1)});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', 0.5);
                collectable.setAttribute("height", 0.5);
                collectable.setAttribute("depth", 0.5);
                collectable.setAttribute("box-collider", '');
                collectables.push(collectable);
                platformsEntity.appendChild(collectable);  
            }
            startup();
            //Append the platform with everything a single platform has to the scene
            scene.appendChild(platformsEntity);
            //Don't run script until we have a scene!
            if (scene.hasLoaded) {
                run();
            } else {
                scene.addEventListener('loaded', run);
            }
            // Left controller (X and Y buttons)
            document.querySelector('#leftHand').addEventListener('xbuttondown', function () {
                kickTrigger = true;
            });
            document.querySelector('#leftHand').addEventListener('xbuttonup', function () {
                kickTrigger = false;
            });
            document.querySelector('#leftHand').addEventListener('ybuttondown', function () {
                bellTrigger = true;
            });
            document.querySelector('#leftHand').addEventListener('ybuttonup', function () {
                bellTrigger = false;
            });
            document.querySelector('#leftHand').addEventListener('triggerdown', function () {
                //console.log('Left trigger pressed');
            });
            // Right controller (A and B buttons)
            document.querySelector('#rightHand').addEventListener('abuttondown', function () {
                snareTrigger = true;
            });
            document.querySelector('#rightHand').addEventListener('abuttonup', function () {
                snareTrigger = false;
            });
            document.querySelector('#rightHand').addEventListener('bbuttondown', function () {
                hihatTrigger = true;
            });
            document.querySelector('#rightHand').addEventListener('bbuttonup', function () {
                hihatTrigger = false;
            });
            document.querySelector('#rightHand').addEventListener('triggerdown', function () {
                //console.log('Right trigger pressed');
            });
            //inputs key down
            document.addEventListener("keydown", function(event) {
                if(event.key == '1'){
                    kickTrigger = true;
                }
                if(event.key == '2'){
                    snareTrigger = true;
                }
                if(event.key == '3'){
                    hihatTrigger = true;
                }
                if(event.key == '4'){
                    bellTrigger = true;
                }
                if(event.key == 'q' || event.key == 'Q'){
                    destroyStep = true;
                    console.log("Q is pressed");
                }     
                keyPressed = event.key;
            });
            //inputs key up
            document.addEventListener("keyup", function(event) {
                if(event.key == '1'){
                    kickTrigger = false;
                }
                if(event.key == '2'){
                    snareTrigger = false;
                }
                if(event.key == '3'){
                    hihatTrigger = false;
                }
                if(event.key == '4'){
                    bellTrigger = false;
                }
                if(event.key == 'q' || event.key == 'Q'){
                    destroyStep = false;
                } 
                keyPressed = event.key;
            });
            //have we collected collectable? 
            function logCollected(event) {
                const collectable = document.getElementById('collectable');
                collectableCount += 1;
                collectablesFound += 1;
                collectablePicked = true;
                for(let i = 0; i < collectables.length; i++){   
                    collectables.splice(i,1);
                    platformsEntity.removeChild(collectable);
                }
            }
            function setupEventListener(entity) {
                // Remove any old event listeners
                entity.removeEventListener('collected', logCollected);
                // Add a new event listener
                entity.addEventListener('collected', logCollected);
            }
            document.addEventListener('DOMContentLoaded', () => {
                const entity = document.querySelector('#collectable');
                setupEventListener(entity);
            });
            //add event listener for new collectable
            function onNewEntityAdded(entity) {
                setupEventListener(entity);
            }
            //check if we're jump and overground for collectible use
            document.addEventListener('DOMContentLoaded', function() {
                let player = document.querySelector('#player');
                player.addEventListener('state-changed', function(event) {
                    isJumping = event.detail.isJumping;
                    isOverGround = event.detail.isOverGround;
                });
            });
            //playhead collision
            document.addEventListener('DOMContentLoaded', function () {
                //get the scene
                const scene = document.querySelector('a-scene');
                //event listener for the 'bonked' event
                scene.addEventListener('bonked', function (event) {
                    hasBonked = true;
                });
                scene.addEventListener('hasEnded', function (event){

                    // use the boolean value as needed
                    hasEnded = true;
                })
            });
            //which direction are we facing
            function headingDirection(player) {
                const rotation = player.getAttribute("rotation");
                let heading = rotation.y;
                //normalize direction
                heading = (heading + 360000) % 360;

                let facing = "";
                if (heading >= 0 && heading <= 45 || heading > 315 && heading < 360) {
                    facing = "northWest";
                } else if (heading > 45 && heading <= 90) {
                    facing = "westNorth";
                } else if (heading > 90 && heading <= 135) {
                    facing = "westSouth";
                } else if (heading > 135 && heading <= 180) {
                    facing = "southWest";
                } else if (heading > 180 && heading <= 225) {
                    facing = "southEast";
                } else if (heading > 225 && heading <= 270) {
                    facing = "eastSouth";
                } else if (heading > 270 && heading <= 315) {
                    facing = "eastNorth";
                }
                return facing;
            }
            //spend collectables (to generate platforms)
            function useCollectables(player, facing, inputs) {
                const playerPos = player.getAttribute('position');

                if (collectableCount <= 0 || isOverGround !== true || isJumping === true) {
                    return;
                }
                const validInputs = ['1', '2', '3', '4'];
                if (!validInputs.includes(inputs)) {
                    return;
                }
                const directions = {
                    northWest: { x: '-x', z: '-z' },
                    westNorth: { x: '-x', z: '-z' },
                    westSouth: { x: '-x', z: 'z' },
                    southWest: { x: '-x', z: 'z' },
                    southEast: { x: 'x', z: 'z' },
                    eastSouth: { x: 'x', z: 'z' },
                    eastNorth: { x: 'x', z: '-z' },
                    northEast: { x: 'x', z: '-z' },
                };
                const direction = directions[facing];

                if (!direction) {
                    return;
                }

                let newOrientation;
                if (previousOrientation === 'z' || previousOrientation === '-z') {
                    newOrientation = (direction.x === 'x' || direction.x === '-x') ? direction.x : direction.z;
                } else {
                    newOrientation = (direction.z === 'z' || direction.z === '-z') ? direction.z : direction.x;
                }
//                /stepSequencer();
                generatePlatforms(playerPos, stepSequenceLength, inputs, newOrientation);
                previousOrientation = newOrientation;
            }
            //we move this shit
            function movePlayheads() {
                const reverseOffset = (stepSequenceLength - 1) * platformSize;
                const otherReverseOffset = (stepSequenceLength - 1) * platformSize;

                for (let i = 0; i < playheads.length; i++) {
                    let localMetro = playheads[i].modmult == 2 ? doubleMetro : metro;
                    const modMetro = -(localMetro - playheads[i].modDel) % stepSequenceLength;
                    const playheadPos = playheads[i].p.getAttribute('position');
                    const playheadSize = parseFloat(playheads[i].p.getAttribute('width'));

                    let normalisedStart, difference, newPosition;

                    if (playheads[i].o == "-z" || playheads[i].o == "z") {
                        normalisedStart = (Math.abs(playheads[i].startX) / platformSize);
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newZ = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheadPos.x,
                            y: playheadPos.y,
                            z: playheads[i].o == "-z"
                            ? playheads[i].startZ + newZ - reverseOffset
                            : playheads[i].startZ - newZ + reverseOffset
                        };
                    } else {
                        normalisedStart = (Math.abs(playheads[i].startZ) / platformSize) % stepSequenceLength;
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newX = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheads[i].o == "-x"
                            ? playheads[i].startX + newX - reverseOffset
                            : playheads[i].startX - newX + reverseOffset,
                            y: playheadPos.y,
                            z: playheadPos.z
                        };
                    }

                    playheads[i].p.setAttribute('position', newPosition);
                }
            }
            //everything makes platforms appear
            function generatePlatforms(playerPos, numSteps, inputs, orientation){
                //make sure we turn off our collectable
                collectableCount--;
                difficultyMapper();

                //floor playerX and Z so we don't prematurely slide off of platform edge
                let playerFlooredX = Math.floor(0.5+(playerPos.x)/platformSize)*platformSize;
                let playerFlooredZ = Math.floor(0.5+(playerPos.z)/platformSize)*platformSize;

                //floor our playhead with an offset equal to half player width so it doesn't glitch on contact with platforms
                let myX = Math.floor(0.5+(playerPos.x)/platformSize)*platformSize;
                let myZ = Math.floor(0.5+(playerPos.z)/platformSize)*platformSize;

                //update the offset for our step sequencer based on what platform we are over when we generate new ones. 
                //stepOffset = currentPlayerStep + stepOffset%16;
                stepOffset = ((stepOffset + stepCheck)%16);
                //console.log("stepOffset", stepOffset);
                //increment placementID - this is used so we can keep track of which platforms relate to which placement (useful for deletion)
                branchID = branchID + 1;

                //change colour of platforms based on input type
                r = 255;
                g = 255;
                b = 255;

                let platformLabel;

                switch (inputs) {
                    case '1':
                        platformLabel = 'kicks';
                        r = 255;
                        g = 165;
                        b = 0;
                        break;
                    case '2':
                        platformLabel = 'snares';
                        r = 255;
                        g = 210;
                        b = 128;
                        break;
                    case '3':
                        platformLabel = 'hihats';
                        r = 0;
                        g = 191;
                        b = 123;
                        break;
                    case '4':
                        platformLabel = 'bells';
                        r = 0;
                        g = 255;
                        b = 165;
                        break;
                    default:
                        break;
                }
                //generate our platform floor 
                for(let i = numSteps-1; i >= 0; i--){
                    let platform = document.createElement('a-box');
                    platform.setAttribute('class', 'ground');
                    //platform.setAttribute('id', 'step ' + i);
                    platform.setAttribute('id', 'platform' );
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute('scale',  {x: 1, y: 1, z: 1});
                    platform.setAttribute('box-collider', '');
                    //colour the new platforms with a sick fade yo
                    calcR = r-Math.round(Math.abs((r/numSteps) *(i%numSteps)));
                    calcG = g-Math.round(Math.abs((g/numSteps) *(i%numSteps)));
                    calcB = b-Math.round(Math.abs((b/numSteps) *(i%numSteps)));; 
                    let rgbString = `rgb(${calcR}, ${calcG}, ${calcB})`;
                    platform.setAttribute('color', rgbString);  
                    //platform.setAttribute('material', {color: rgbString, transparent: 'true', opacity: '0.5'});

                    //set position based on player orientation
                    if(orientation == '-x'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX -(i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            } else {
                                platform.setAttribute('position', {x: playerFlooredX +(-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        } else {
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX -(i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            } else {
                                platform.setAttribute('position', {x: playerFlooredX +(-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                    } 
                    else if(orientation == '-z'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX < 0){
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            } else {
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }
                        } else  {
                            if(playerFlooredX <=0){
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }else {
                                platform.setAttribute('position', {x:playerFlooredX  , y: playerPos.y, z:playerFlooredZ -(i*platformSize)});
                            }
                        }
                    }
                    else if(orientation == 'z'){
                        if(playerFlooredZ < 0){
                            if(playerFlooredX <0){
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            } else {
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            }
                        } else {
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ - (-i *platformSize)});
                            } else{
                                platform.setAttribute('position', {x:playerFlooredX , y: playerPos.y, z: playerFlooredZ + (i *platformSize)});
                            }
                        }
                    }
                    else if(orientation == 'x'){
                        if(playerFlooredZ <= 0){
                            if(playerFlooredX < 0){
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }else {
                                platform.setAttribute('position', {x: playerFlooredX - (-i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                        else{
                            if(playerFlooredX <= 0){
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});

                            } else{
                                platform.setAttribute('position', {x: playerFlooredX + (i*platformSize), y: playerPos.y, z: playerFlooredZ});
                            }
                        }
                    }
                    platforms.push({p:platform, s: 15-i, o: 0, branch: branchID, sound: platformLabel, orientation: orientation});

                    platformsEntity.appendChild(platform);
                }
                //playhead biz
                let playhead = document.createElement('a-box');
                playhead.setAttribute('class', 'playheads');
                playhead.setAttribute("box-collider", '');
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                playhead.setAttribute('side', 'double');

                //use a lil bit of rng to spice up the chance
                let rng = Math.random();

                //our kick PlayHeads
                if(sequenceOrder[sequenceOrder.length-1] == 0){
                    playhead.setAttribute('width', 3* platformSize-0.1);
                    playhead.setAttribute("height", platformSize-0.1);
                    playhead.setAttribute("depth",3 * platformSize-0.1);
                    //snare playheads
                } 
                else if(sequenceOrder[sequenceOrder.length-1] == 1){
                    playhead.setAttribute('width', (platformSize-0.1)/2);
                    playhead.setAttribute("height",(platformSize-0.1)*3);
                    playhead.setAttribute("depth", (platformSize-0.1)/2);
                    //hihat playheads
                } 
                else if(sequenceOrder[sequenceOrder.length-1] == 2){
                    if (orientation == 'x' || orientation == '-x'){
                        playhead.setAttribute('width', (platformSize-0.1)*4);
                        playhead.setAttribute("height",(platformSize-0.1)/4);
                        playhead.setAttribute("depth", (platformSize-0.1)/4);   
                    } else {
                        playhead.setAttribute('width', (platformSize-0.1)/4);
                        playhead.setAttribute("height",(platformSize-0.1)/4);
                        playhead.setAttribute("depth", (platformSize-0.1)*4);     
                    }
                } 
                else{
                    if (orientation == 'x' || orientation == '-x'){
                        playhead.setAttribute('width', (platformSize-0.1));
                        playhead.setAttribute("height",(platformSize-0.1)/4);
                        playhead.setAttribute("depth", (platformSize-0.1)*3);   
                    } else {
                        playhead.setAttribute('width', (platformSize-0.1)*3);
                        playhead.setAttribute("height",(platformSize-0.1)/4);
                        playhead.setAttribute("depth", (platformSize-0.1));     
                    }
                } 
                //                }
                //use difficult to seed playheads with different metroSpeeds
                let modSpeed = 1;
                if(difficulty < 8){
                    modSpeed = 1;
                }
                if(difficulty >=8 && difficulty < 16){  
                    modSpeed = 1; 

                } else if (difficulty >= 16 && difficulty <= 28){
                    if(rng > 0.8){
                        modSpeed =2; 
                    }  else {
                        modSpeed = 1;
                    }
                } else if (difficulty >= 28 && difficulty <=36){
                    if(rng > 0.7){
                        modSpeed =2; 
                    }else{
                        modSpeed = 1;
                    }
                } else if(difficulty > 36 && difficulty <=48){
                    if(rng > 0.3){
                        modSpeed =2; 
                    }else{
                        modSpeed = 1;
                    }
                } 

                //using number of steps to figure out if we need to offset starting point in the cycle
                let val;
                if (playerSteps.length > 3){
                    val = playerSteps[playerSteps.length-1] - playerSteps[playerSteps.length-2];
                } else{
                    val = 0;
                }
                //set orientation
                let newPosition = {x: myX, y: playerPos.y + platformSize + 0.01, z: myZ};
                playhead.setAttribute('position', newPosition);
                let playheadData = {
                    p: playhead,
                    o: orientation,
                    startX: myX,
                    startZ: myZ,
                    modDel: stepOffset - currentPlayerStep,
                    modmult: modSpeed
                };
                playheads.push(playheadData);

                //append to entity in scene
                platformsEntity.appendChild(playhead);
                //wait so our platforms positions are updated and then place collectable

                //generate the collectable for that platform
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', platformSize/4);
                collectable.setAttribute("height", platformSize/4);
                collectable.setAttribute("depth", platformSize/4);
                collectable.setAttribute("box-collider", '');

                //quick and dirty as main way is fucked/too computational expensive
                let away = stepSequenceLength-((difficulty/collectablesFound+1)%8)-1;

                if(orientation == '-x'){
                    //ofset the x by the negative of sequence so it places it at the end
                    collectable.setAttribute('position', {x: myX -((away)*platformSize), y: platformSize+playerPos.y, z:myZ});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == '-z'){      
                    collectable.setAttribute('position', {x: myX, y: platformSize+playerPos.y, z:myZ-((away)*platformSize)});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == 'z'){
                    collectable.setAttribute('position', {x: myX, y: platformSize+playerPos.y, z:myZ+((away)*platformSize)});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == 'x'){
                    collectable.setAttribute('position', {x: myX +((away)*platformSize), y: platformSize+playerPos.y, z:myZ});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize, z: place.z})
                }
                collectables.push(collectable);
                //append to entity in scene
                platformsEntity.appendChild(collectable);
                onNewEntityAdded(collectable);

                //replace our player so they don't get stuck inside the new dropped platform
                player.setAttribute('position', {x: playerPos.x, y: playerPos.y + (platformSize*3)+0.1, z: playerPos.z});

            }
            // use step check and inputs to trigger sound / add them to instrument array 
            function stepSequencer() {
                const playerPos = player.getAttribute('position');
                const playerX = playerPos.x;
                const playerY = playerPos.y;
                const playerZ = playerPos.z;
                const halfPlatformSize = platformSize / 2;

                for (let i = 0; i < platforms.length; i++) {
                    const platformPos = platforms[i].p.getAttribute('position');
                    const platformX = platformPos.x;
                    const platformY = platformPos.y;
                    const platformZ = platformPos.z;

                    if (
                        playerX > platformX - halfPlatformSize &&
                        playerX < platformX + halfPlatformSize &&
                        playerY >= platformY &&
                        playerY <= platformY + (platformSize + 1.1) &&
                        playerZ > platformZ - halfPlatformSize &&
                        playerZ < platformZ + halfPlatformSize
                    ) {
                        let standingStep = (platforms[i].s + platforms[i].o) % stepSequenceLength;
                        stepCheck = platforms[i].s;
                        currentPlayerStep = standingStep;
                        currentBranch = platforms[i].branch;

                        if (collectableCount > 0) {
                            const triggerInfo = [
                                { trigger: kickTrigger, index: 0, setFalse: () => kickTrigger = false },
                                { trigger: snareTrigger, index: 1, setFalse: () => snareTrigger = false },
                                { trigger: hihatTrigger, index: 2, setFalse: () => hihatTrigger = false },
                                { trigger: bellTrigger, index: 3, setFalse: () => bellTrigger = false },
                            ];

                            for (const info of triggerInfo) {
                                if (info.trigger) {
                                    myDrumSequence.push({ p: info.index, s: standingStep, v: 127 });
                                    sampler.setSequence(myDrumSequence, 4);
                                    sequenceOrder.push(info.index);
                                    playerSteps.push(currentPlayerStep);
                                    selector = info.index;
                                    info.setFalse();
                                }
                            }
                        }
                    }
                }
            }
            //grab our sample triggers and store them as bools to do stuff with 
            function sequenceTracker(myDrumSequence) {
                for (let i = 0; i < myDrumSequence.length; i++) {
                    const drumItem = myDrumSequence[i];
                    const drumIndex = drumItem.s;

                    if (drumItem.v > 0) {
                        switch (drumItem.p) {
                            case 0:
                                kicks[drumIndex] = true;
                                break;
                            case 1:
                                snares[drumIndex] = true;
                                break;
                            case 2:
                                hihats[drumIndex] = true;
                                break;
                            case 3:
                                bells[drumIndex] = true;
                                break;
                        }
                    }
                }
            }
            //mapped our beats so we can check their distribution
            function mappedBar(bar) {
                //steps mapped
                const stepValues = bar.map((bool, index) => {
                    const mapping = [8, 1, 4, 2];
                    const mappingIndex = index % 4;
                    return bool ? mapping[mappingIndex] : 0;
                });
                // Beat values
                const beatValues = [];
                for (let i = 0; i < stepValues.length; i += 4) {
                    let sum = 0;
                    for (let j = i; j < i + 4; j++) {
                        sum += isNaN(stepValues[j]) ? 0 : stepValues[j];
                    }
                    beatValues.push(sum);
                }           
                return {stepValues, beatValues};
            }; 
            //nifty function for checking individual bar distribution
            function barCheck(beats){
                if(beats[0] > beats[1] && beats[2] & beats[3]){
                    return 5;
                }
                if(beats[1] > beats[0]&& beats[2] && beats[3]){
                    return 10;
                }
                if(beats[2] > beats[0]&& beats[1] && beats[3]){
                    return 5;
                }
                if(beats[3] > beats[0]&& beats[1] && beats[2]){
                    return 5;
                }  else {
                    return 0;
                } 
                //                if(beats[0] + [1] > beats[2] + beats[3]){
                //                }
                //                if(beats[1] + [2] > beats[0] + beats[3]){
                //                }
            }
            //nifty distance calc for how far things are from other things
            function distance3D(a, b) {
                return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow(a.z - b.z, 2));
            }
            //lil scale
            function scale (number, inMin, inMax, outMin, outMax) {
                return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
            }
            //work out the best place to distribute the new collectable
//            function collectableDistribution(){
//                //lets find where platforms are so we can place collectables over them
//                const playerPosition = player.getAttribute('position');
//                let meanPlatform = null;
//                let meanPlatformIndex = -1;
//                let meanPlatformDistance = -Infinity;
//                //offset for how mean the collectable will be
//                const randomOffset = 8; 
//                //offsets for friendly collectable range
//                const minClosestIndex = 8;
//                const maxClosestIndex = 12;
//                //checking if there is a platform above us, if there is we can't place it there!
//                function isPlatformTooClose(platform1, platform2, platformSize) {
//                    const pos1 = platform1.getAttribute('position');
//                    const pos2 = platform2.getAttribute('position');
//                    const width1 = platform1.getAttribute('width');
//                    const depth1 = platform1.getAttribute('depth');
//                    const width2 = platform2.getAttribute('width');
//                    const depth2 = platform2.getAttribute('depth');
//
//                    const minOverlap = platformSize * 2;
//                    const xOverlap = Math.abs(pos1.x - pos2.x) <= (width1 + width2) / 2;
//                    const zOverlap = Math.abs(pos1.z - pos2.z) <= (depth1 + depth2) / 2;
//                    const yOverlap = pos2.y - pos1.y < minOverlap && pos2.y - pos1.y > 0;
//
//                    return xOverlap && zOverlap && yOverlap;
//                }
//                //if we need to find another one
//                function findPlatformWithoutCloseOverlap(platforms, platformSize) {
//                    for (let i = 0; i < platforms.length; i++) {
//                        let hasOverlap = false;
//                        for (let j = 0; j < platforms.length; j++) {
//                            if (i !== j && isPlatformTooClose(platforms[i].p, platforms[j].p, platformSize)) {
//                                hasOverlap = true;
//                                break;
//                            }
//                        }
//                        if (!hasOverlap) {
//                            return { platform: platforms[i].p, index: i };
//                        }
//                    }
//                    return { platform: null, index: -1 };
//                }
//                //find within range
//                function findPlatformInRangeWithoutCloseOverlap(platforms, platformSize, startIndex, endIndex) {
//                    for (let i = startIndex; i <= endIndex; i++) {
//                        let hasOverlap = false;
//                        for (let j = 0; j < platforms.length; j++) {
//                            if (i !== j && isPlatformTooClose(platforms[i].p, platforms[j].p, platformSize)) {
//                                hasOverlap = true;
//                                break;
//                            }
//                        }
//                        if (!hasOverlap) {
//                            return { platform: platforms[i].p, index: i };
//                        }
//                    }
//                    return { platform: null, index: -1 };
//                }
//                //get our meanest platform
//                platforms.forEach((platform, index) => {
//                    const entity = platform.p;
//                    const entityPosition = entity.getAttribute('position');
//                    const distance = distance3D(playerPosition, entityPosition);
//
//                    if (distance > meanPlatformDistance) {
//                        meanPlatformDistance = distance;
//                        meanPlatform = entity;
//                        meanPlatformIndex = index;
//                    }
//                });
//                //our meanest platform offset to slightly less mean
//                let minDistance = meanPlatformDistance - randomOffset;
//                let rudePlatform = null;
//                let rudePlatformIndex = -1;
//                let closestDistanceDifference = Infinity;
//
//                platforms.forEach((platform, index) => {
//                    const entity = platform.p;
//                    const entityPosition = entity.getAttribute('position');
//                    const distance = distance3D(playerPosition, entityPosition);
//
//                    if (distance >= minDistance && distance <= meanPlatformDistance) {
//                        const distanceDifference = Math.abs(distance - minDistance);
//                        if (distanceDifference < closestDistanceDifference) {
//                            closestDistanceDifference = distanceDifference;
//                            rudePlatform = entity;
//                            rudePlatformIndex = index;
//                        }
//                    }
//                });
//                // Our friendlier platforms with boundary for how friendly and how mean
//                let closestPlatforms = platforms.map((platform, index) => {
//                    const entity = platform.p;
//                    const entityPosition = entity.getAttribute('position');
//                    const distance = distance3D(playerPosition, entityPosition);
//                    return {index, distance};
//                })
//                .sort((a, b) => a.distance - b.distance)
//                .slice(minClosestIndex, maxClosestIndex + 1);
//
//                const friendlyPlatform = closestPlatforms[Math.floor(Math.random() * closestPlatforms.length)];
//
//                //post-check
//                const meanPlatformResult = findPlatformWithoutCloseOverlap([{p: meanPlatform}], platformSize);
//                const rudePlatformResult = findPlatformWithoutCloseOverlap([{p: rudePlatform}], platformSize);
//                const friendlyPlatformResult = findPlatformWithoutCloseOverlap([{p: platforms[friendlyPlatform.index].p}], platformSize);
//                const originalIndex = friendlyPlatformResult.index;
//                const startIndex = (friendlyPlatformResult.index + platforms.length-24) % platforms.length;
//                const endIndex = platforms.length;
//                const friendlyPlatformInRangeResult = findPlatformInRangeWithoutCloseOverlap(platforms, platformSize, startIndex, endIndex);
//
//                let infront = platforms[platforms.length-8];
//                movingCollectablesLocations = [infront.p,friendlyPlatformInRangeResult.platform,rudePlatformResult.platform,meanPlatformResult.platform ];
//
//                //use a bit of randomness to alter which potential starting point the collectable can be. 
//                let rng = Math.random();
//
//                //using the beat distribution score (difficulty) to determine where to place collectables
//                if (difficulty <= 8) {
//
//                    return friendlyPlatformInRangeResult.platform;
//                }
//                else if (difficulty > 8 && difficulty < 20){
//                    if(rng < 0.6){
//                        return friendlyPlatformInRangeResult.platform;                  
//                    } else{
//                        return rudePlatformResult.platform;
//                    }
//                }
//                else if(difficulty >= 20 && difficulty< 50){
//                    if(rng > 0.3){
//                        return friendlyPlatformInRangeResult.platform;  
//                    } else{
//                        return rudePlatformResult.platform;
//                    }
//                }
//                else if(difficulty >= 50 && difficulty < 65){
//                    if(rng > 0.15){
//                        rudePlatformResult.platform;
//                    } else{
//                        return friendlyPlatformInRangeResult.platform;  
//                    } 
//                }
//                else {
//                    return meanPlatformResult.platform;
//                }
//            }
            //move our collectables around the steps environment based on step distribution
            function difficultyMapper(){
                //mapped bar returns 16 step Values mapped to 8, 1, 4, 2
                let mappedKicks = mappedBar(kicks);
                let mappedSnares = mappedBar(snares);
                let mappedHihats = mappedBar(hihats);
                let mappedBells = mappedBar(bells);
                let allKicksStepValues = mappedBar(kicks).stepValues;
                let allSnaresStepValues = mappedBar(snares).stepValues;
                let allHihatsStepValues = mappedBar(hihats).stepValues;
                let allBellsStepValues = mappedBar(bells).stepValues;
                let allKicksBeatValues = mappedBar(kicks).beatValues;
                let allSnaresBeatValues = mappedBar(snares).beatValues;
                let allHihatsBeatValues = mappedBar(hihats).beatValues;
                let allBellsBeatValues = mappedBar(bells).beatValues;
                //let difficulty = 0;
                //our distances so we know where we're mapping notes too
                let sumKicks = 0;
                let sumSnares = 0;
                let sumHihats = 0;
                let sumBells = 0;
                let sumAllSteps =[];
                //where to play then next collectable
                let collectablePlacement;
                //get sums of all our steps
                for(let i = 0; i < 16; i++){
                    sumKicks += allKicksStepValues[i];
                    sumSnares += allSnaresStepValues[i];
                    sumHihats += allHihatsStepValues[i];
                    sumBells += allBellsStepValues[i];
                    sumAllSteps.push(allKicksStepValues[i]+allSnaresStepValues[i]+allHihatsStepValues[i]+allBellsStepValues[i]);
                }
                //increase difficulty abit every collection
                for(let i = 0; i<collectablesFound; i++){
                    difficulty += 5;
                }
                //increase difficult based on kicks
                if(sumKicks > 12 && sumKicks <=18){
                    difficulty +=25;
                }
                //increase difficulty based on snares
                if(sumSnares > 12 && sumSnares <= 16 ){
                    difficulty +=25;
                } 
                else if (sumSnares > 16){
                    difficulty +=30;
                }
                //increase difficult based on hihats and bells
                if(sumHihats + sumBells > 20){
                    difficulty +=15;
                }
                //reward players if they can manage some parity between distributions
                if(allKicksBeatValues[0] > 0 && allKicksBeatValues[0] == allKicksBeatValues[1] && allKicksBeatValues[2] && allKicksBeatValues[3]){
                    difficulty -=15;
                } 
                if(allHihatsBeatValues[0] > 0 && allHihatsBeatValues[0] == allHihatsBeatValues[1] && allHihatsBeatValues[2] && allHihatsBeatValues[3] || allBellsBeatValues[0] > 0 && allBellsBeatValues[0] == allBellsBeatValues[1] && allBellsBeatValues[2] && allBellsBeatValues[3]){
                    difficulty -=20;
                }
                //when distribution is too lopsided make target location very far way. 
                difficulty = difficulty + barCheck(sumAllSteps);

            }
            //update our collectables / move them around in case one of them gets stuck
            function updateCollectables(){

                let bang = eventFixer%4;
                let tempPos = movingCollectablesLocations[bang];

                for (let i = 0; i < movingCollectablesLocations.length; i++) { 
                    if (typeof movingCollectablesLocations[i] !== 'undefined') {  
                        collectables[0].setAttribute('position', {x: tempPos.x, y: tempPos.y + platformSize, z: tempPos.z})
                    } else {
                        collectables[0].setAttribute('position', {x: place.x, y: place.y, z: place.z})
                    }
                }
            }
            //get the shuffled orderd for our new platform layer
            function reorderSamples(sample, currentPlayerStep) {
                const reordered = [];
                for (let i = 0; i < 16; i++) {
                    reordered[i] = sample[(currentPlayerStep + 1 +  i) % 16];
                }
                return reordered;
            }
            //helper to minimise setAttributes
            function updatePlatformAttributes(platform, width, height, depth) {
                platform.p.setAttribute('width', width);
                platform.p.setAttribute('height', height);
                platform.p.setAttribute('depth', depth);
                platform.p.setAttribute('scale', { x: 1, y: 0.98, z: 1 });
            }
            //update our platforms when we trigger the corresponding step yo
            function updatePlatforms() {
                let base = playerSteps.length * 16;
                let reorderedSamples;

                switch (selector) {
                    case 0:
                        reorderedSamples = reorderSamples(kicks, currentPlayerStep);
                        break;
                    case 1:
                        reorderedSamples = reorderSamples(snares, currentPlayerStep);
                        break;
                    case 2:
                        reorderedSamples = reorderSamples(hihats, currentPlayerStep);
                        break;
                    case 3:
                        reorderedSamples = reorderSamples(bells, currentPlayerStep);
                        break;
                    default:
                        return;
                }
                for (let i = 0; i < reorderedSamples.length; i++) {
                    if (reorderedSamples[i] === true) {
                      
                        
                        let platform = platforms[i + base];

                        switch (selector) {
                            case 0:
                                updatePlatformAttributes(platform, 9, platformSize, 9);
                                break;
                            case 1:
                                let width = (platform.orientation == 'x' || platform.orientation == '-x') ? 6 : 1.5;
                                let depth = (platform.orientation == 'x' || platform.orientation == '-x') ? 1.5 : 6;
                                updatePlatformAttributes(platform, width, 9, depth);
                                break;
                            case 2:
                                let hatWidth = (platform.orientation == 'x' || platform.orientation == '-x') ? 9 : 1.5;
                                let hatDepth = (platform.orientation == 'x' || platform.orientation == '-x') ? 1.5 : 9;
                                updatePlatformAttributes(platform, hatWidth, 0.75, hatDepth);
                                break;
                            case 3:
                                updatePlatformAttributes(platform, 9, 0.98, 9);
                                break;
                        }
                    }
                }
                selector = -1;
            }
            //destroy our playforms if our players want to do that
            function destroyer(){
                if(destroyStep == true && currentBranch > 0){
                    for (let i = platforms.length - 1; i >= 0; i--) {
                        if (platforms[i].branch === currentBranch) {
                            platforms[i].p.remove();
                            platforms.splice(i, 1); 
                            collectableCount+=1;
                        }
                    }
                }
            }
            //this is where the real magic happens
            function updateSounds(){
                //have we been bonked by a playhead
                if(hasBonked == true){
                    let randomNote = notes[Math.floor(Math.random()*notes.length)];
                    enemySynth.noteon(randomNote, 127);
                    bonking = 1.0;
                    roomSize =1.0;
                    hasBonked = false;
                }
                if(bonking > 0){
                    bonking -= 0.1;
                    reverb += 0.2;
                    enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                }
                if (bonking  <= 0){
                    hasBonked = false;
                    enemySynth.noteoff(62);
                    enemySynth.noteoff(64);
                    enemySynth.noteoff(65);
                    enemySynth.noteoff(69);

                    bonking = 0;
                    enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                } 

                //jump sounds
                if(isJumping == true){
                    filter += 0.5;  
                    backingMidSynth.setParam("lfoFrequency", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                    bassSynth.setParam("cutoff", filter *40);
                    sampler.setParam("rate_1", filter);
                    sampler.setParam("rate_2", filter+0.5);
                    sampler.setParam("rate_3", filter-0.5);
                } else {
                    filter = 0;
                    backingMidSynth.setParam("lfoFrequency", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                } 
                let fall = player.getAttribute('position').y;
                if(fall < -2){
                    let drop = scale(fall,-2, -30, 1.0, 0.1);
                    sampler.setParam("rate_0", drop);
                    sampler.setParam("rate_1", drop);
                    bassSynth.setParams(["adsrPitchMod", drop*-1],["cutoff", drop*100]);
                    backingMidSynth.setParam("lfoFrequency", drop);
                    sampler.setParam("rate_4", drop);
                }
                if(fall <= 70){
                    sampler.setParam("rate_0", 0.5);
                    sampler.setParam("rate_1", 0.5);
                    bassSynth.setParams(["adsrPitchMod", 0],["cutoff",40]);
                    backingMidSynth.setParam("reverbMix", 0.12);
                }

                //our arrangement for backing synths
                if(collectablesFound == 1 && collectablePicked == true){

                    bassSynth.setParam('gain', 1);
                    collectablePicked = false;

                }
                if(collectablesFound == 2 && collectablePicked == true){   
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;                        
                    }                    
                }
                if(collectablesFound == 3 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38},{s:4, l:4, p:36},{s:8, l:4, p:33}, {s:12, l:4, p:36}],2);
                        bassSynth.setLoop(16,4);
                        collectablePicked = false;    
                    }   
                }
                if(collectablesFound == 4 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind(); 
                        bassSynth.setSequence([{s:0, l:16, p:33}],1);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    }   
                }
                if(collectablesFound == 5 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38}, {s:0, l:16, p:48}],4);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    } 
                }
                if(collectablesFound == 6 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38},{s:4, l:4, p:48},{s:8, l:4, p:45}, {s:12, l:4, p:39}],4);
                        bassSynth.setLoop(16,4);
                        backingMidSynth.setSequence([{s:0, l:8, p:a7sus4},
                                                     {s:16, l:8, p:cadd9},
                                                    ],4);
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;    
                    } 
                }
                if(collectablesFound == 7 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:16, p:38}],1);
                        bassSynth.setLoop(32,4);
                        collectablePicked = false;    
                    }

                } 
                enemySynth.getMappedParameters;
                backingMidSynth.getMappedParameters;
                bassSynth.getMappedParameters;  

            }
            //end game reset
            function end(){
                if(hasEnded == true){
                    //TURN OFF SOUND SEQUENTIALLY, REMOVE PLATFORMS, FADE/OR DROP PLAYER TO STARTING POINT, RESET ALL NECESSARY VALUES
                    // collectable count, difficulty value, playerSteps, sequenceOrder, Empty all arrays
                    if(metro%16==0){
                        staging++;
                    }
                    console.log(staging);
                    if(staging %10){
                        scene.setAttribute('background', 'black');
                    }

                }
            }
            instruments.loadModules().then(()=> {

                enemySynth = instruments.addSynth();
                backingMidSynth = instruments.addSynth();
                bassSynth = instruments.addSynth();
                backingMidSynth.setOsc(1);
                bassSynth.setOsc(1);
                enemySynth.setOsc(1);

                var dm79 = [50, 57, 64, 65, 72];
                var eb911 = [51, 58, 65, 67, 69];
                var a7sus4 = [45, 57, 64, 67,47];
                var cadd9 = [48, 62, 64, 67, 72];

                var midSynthSeq = [
                    //start, length, pitches
                    {s:0, l:8, p:dm79},
                    {s:16, l:8, p:eb911},
                    {s:32, l:8, p:a7sus4},
                    {s:48, l:8, p:cadd9},
                ];
                var bassSynthSeq = [ {s:0, l:16, p:38}];


                backingMidSynth.setParams([
                    ["oscFn",3],
                    ["lfoOscFn",0],
                    ["gain",0.4],
                    ["pan",0.5],
                    ["attack",165],
                    ["decay",330],
                    ["sustain",0.58],
                    ["release",495],
                    ["lfoFrequency",0.7],
                    ["lfoPitchMod",0],
                    ["lfoFilterMod",1000],
                    ["lfoAmpMod",0.68],
                    ["adsrPitchMod",1],
                    ["cutoff",957.6],
                    ["reverbMix",0.33],
                    ["roomSize",0.27],
                    ["delay",0],
                    ["delayMix",0.35],
                    ["frequency",440],
                    ["frequency2",220],
                ]);
                enemySynth.setParams([
                    ["oscFn",3],
                    ["lfoOscFn",1],
                    ["gain",2],
                    ["pan",0.5],
                    ["attack",0],
                    ["decay",330],
                    ["sustain",0.1],
                    ["release",1500],
                    ["lfoFrequency",6.3],
                    ["lfoPitchMod",0],
                    ["lfoFilterMod",220],
                    ["lfoAmpMod",0.88],
                    ["adsrPitchMod",0],
                    ["cutoff",1372],
                    ["reverbMix",0.12],
                    ["roomSize",0],
                    ["delay",0],
                    ["delayMix",0],
                    ["frequency",440],
                    ["frequency2",220],
                ]);
                bassSynth.setParams([
                    ["oscFn",3],
                    ["lfoOscFn",1],
                    ["gain",0],
                    ["pan",0.53],
                    ["attack",1155],
                    ["decay",480],
                    ["sustain",0.58],
                    ["release",1185],
                    ["lfoFrequency",10],
                    ["lfoPitchMod",0],
                    ["lfoFilterMod",1000],
                    ["lfoAmpMod",0.78],
                    ["adsrPitchMod",1],
                    ["cutoff",40],
                    ["reverbMix",0],
                    ["roomSize",0],
                    ["delay",0],
                    ["delayMix",0.35],
                    ["frequency",440],
                    ["frequency2",220],
                ]);

                enemySynth.mapped = ["gain","reverbMix","roomSize", "delay","delayMix"];
                backingMidSynth.mapped = ["gain", "lfoFrequency", "lfoPitchMod", "reverb"];
                bassSynth.mapped = ["lfoFrequency", "pan", "cutoff" ,"adsrPitchMod"];

                sampler = instruments.addSampler();
                sampler.loadSample("BD-ER1-CR8000ish.wav", 0);
                sampler.loadSample("DR660SnareLofinice.wav", 1);
                sampler.loadSample("TOM-ER-MicroTom2.wav", 2);
                sampler.loadSample("FX-ER-Sonario.wav", 3);
                sampler.loadSample("FX-ER1-Woodzblox.wav", 4);

                sampler.setParam("rate_0", 1);
                sampler.setParam("rate_1", 1);
                sampler.setParam("rate_2", 1);
                sampler.setParam("rate_3", 1);
                sampler.setParam("rate_4", 1);
                sampler.setParam("pan_0", 0.5);
                sampler.setParam("pan_1", 0.5);
                sampler.setParam("pan_2", 0.5);
                sampler.setParam("pan_3", 0.5);
                sampler.setParam("pan_4", 0.5);
                sampler.setParam("gain_0", 1);
                sampler.setParam("gain_1", 1);
                sampler.setParam("gain_2", 1);    
                sampler.setParam("gain_3", 1);    
                sampler.setParam("gain_4", 1);    

                instruments.playPause();
                instruments.setTempo(tempo);
                sampler.setSequence(myDrumSequence, 4);

                //Sequence and loop set at 4 ticks per beat (1/16ths)
                backingMidSynth.setSequence(midSynthSeq, 4);
                bassSynth.setSequence(bassSynthSeq, 4);
                backingMidSynth.setLoop(16,4);
                bassSynth.setLoop(16,4);
                sampler.setLoop(16,4);
                //instruments.setLoop(32,4);

                instruments.setOnTick((playHeads)=> {
                    //The current playhead of the third instrument added
                    if(playHeads[2] % 3 == 2) {
                        metro+=0.5;
                        //metro++;
//                        sequenceTrigger = true;
                    }
                    //double speed
                    if(playHeads[2] % 3 == 1) {
                        doubleMetro++;
                    }
                    if(playHeads[2] % 48 == 4) {
                        sequenceTrigger = true;
                    } 
                });

            }).catch((err)=> {
                console.log("error", err);
            });
            //start the step sequencer
            document.addEventListener('keydown', (event) => {
                if (event.key){
                    if(soundUP == false){
                        enemySynth.unmute();
                        backingMidSynth.unmute();
                        bassSynth.unmute();
                        sampler.unmute();
                        instruments.playPause();
                        soundUP = true; 
                    } 
                }
            });
            setInterval(run, 50);
            function run() {
                if (soundUP) {
                    movePlayheads();
                    stepSequencer();
                    useCollectables(player, headingDirection(player), keyPressed);
                    updateSounds();
                    sequenceTracker(myDrumSequence);
                    updatePlatforms();
                    destroyer();
                }
                if(hasEnded == true){
                    end();
                }
                if(canStart == true && hasEnded == true){
                    player.setAttribute('position', {x:0, y: 2, z:8});
                    scene.setAttribute('background', {color: 'blue'});
                    killplane.setAttribute('color', 'red');
                    startup();
                    sampler.setParams([["gain_0", 1],["gain_1", 1],["gain_2", 1],["gain_3", 1] ]);
                    bassSynth.setParam('gain', 1);
                    backingMidSynthSeq.setParam('gain', 1);
                    sampler.unmute;
                    backingMidSynth.unmute;
                    bassSynth.unmute;
                    instruments.playPause();
                }
                //sequenceTracker(myDrumSequence);

            }

        </script>
    </body>
</html>
