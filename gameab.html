<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Game B: Red is Dead </title>
         <link rel="stylesheet" type="text/css" href="myStyle.css">
        <script src="enable-threads.js"></script>
        <script crossorigin src="maxiInstruments.v.0.7.1.js"></script>
        <script src="./dist/aframe-master.min.js"></script>
	<!-- oculus controller -->
        <script>AFRAME.registerComponent('controller', {
                schema: {
                    moveSpeed: {type: 'number', default: 3.6},
                    smoothness: {type: 'number', default: 0.05}
                },
                init: function() {
                    this.leftAxisX = 0;
                    this.leftAxisY = 0;
                    let self = this;

                    this.el.addEventListener('thumbstickmoved', function(event) {
                        self.leftAxisX = event.detail.x;
                        self.leftAxisY = event.detail.y;
                    });

                    //X button
                    this.el.addEventListener('xbuttondown', function(event) {
                        self.el.emit('xbuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener('xbuttonup', function(event) {
                        self.el.emit('xbuttonreleased', {pressed: false});
                    });

                    //Y button
                    this.el.addEventListener('ybuttondown', function(event) {
                        self.el.emit('ybuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener('ybuttonup', function(event) {
                        self.el.emit('ybuttonreleased', {pressed: false});
                    });

                    //A button
                    this.el.addEventListener('abuttondown', function(event) {
                        self.el.emit('abuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener('abuttonup', function(event) {
                        self.el.emit('abuttonreleased', {pressed: false});
                    });

                    //B button
                    this.el.addEventListener('bbuttondown', function(event) {
                        self.el.emit('bbuttonpressed', {pressed: true});
                    });

                    this.el.addEventListener('bbuttonup', function(event) {
                        self.el.emit('bbuttonreleased', {pressed: false});
                    });

                    //left trigger
                    this.el.addEventListener('triggerdown', function(event) {
                        self.el.emit('lefttriggerdown', {pressed: true});
                    });

                    this.el.addEventListener('triggerup', function(event) {
                        self.el.emit('lefttriggerup', {pressed: false});
                    });

                    //right trigger
                    this.el.addEventListener('triggerdown', function(event) {
                        self.el.emit('righttriggerdown', {pressed: true});
                    });

                    this.el.addEventListener('triggerup', function(event) {
                        self.el.emit('righttriggerup', {pressed: false});
                    });

                    //left grip
                    this.el.addEventListener('gripdown', function(event) {
                        self.el.emit('leftgripdown', {pressed: true});
                    });

                    this.el.addEventListener('gripup', function(event) {
                        self.el.emit('leftgripup', {pressed: false});
                    });

                    //right grip
                    this.el.addEventListener('gripdown', function(event) {
                        self.el.emit('rightgripdown', {pressed: true});
                    });

                    this.el.addEventListener('gripup', function(event) {
                        self.el.emit('rightgripup', {pressed: false});
                    });
                },

                tick: function() {
                    let player = document.querySelector("#player");
                    let camera = document.querySelector("#camera");
                    let direction = new THREE.Vector3();
                    let left = new THREE.Vector3();

                    //camera's direction for movement
                    camera.object3D.getWorldDirection(direction);

                    //lock y
                    direction.y = 0;

                    //normalize the direction vector (tsettingy to 0 can fuck vector length)
                    direction.normalize();

                    //work out left direction
                    left.crossVectors(camera.object3D.up, direction);

                    //movement based on thumbstick position and speed
                    let forwardMovement = direction.multiplyScalar(this.leftAxisY * this.data.moveSpeed);
                    let sideMovement = left.multiplyScalar(this.leftAxisX * this.data.moveSpeed);

                    //add forward and side movement vectors to get the total movement vector
                    let movement = new THREE.Vector3().addVectors(forwardMovement, sideMovement);
                    let desiredPosition = new THREE.Vector3().addVectors(player.object3D.position, movement);
                    //smooth
                    player.object3D.position.lerp(desiredPosition, this.data.smoothness);
                },
            });
        </script> 
        <!-- jump and fall and detect ground and the many edge cases -->
        <script>AFRAME.registerComponent('jump', {
                schema: {
                    groundSelector: { type: "string", default: ".ground"},
                },
                init: function () {
                    this.grounds = [];
                    this.player = document.querySelector('#player');
                    this.isOverGround = true;
                    this.isOnGround = false;
                    this.isJumping = false;
                    this.jumpHeight = 0.30;
                    this.jumpSpeed = this.jumpHeight;
                    this.fallSpeed = 0.5;
                    this.canJump = true;
                    this.groundCheck = { isOverGround: false, groundY: 0, halfGroundX: 0, halfGroundZ: 0, lowY: 0, highY: 0 };
                    let self = this; 
                    //initialize
                    this.updateGrounds();

                    this.el.sceneEl.addEventListener('child-attached', this.updateGrounds.bind(this));
                    this.el.sceneEl.addEventListener('child-detached', this.updateGrounds.bind(this));

                    //X
                    document.querySelector('#left-controller').addEventListener('xbuttondown', function(evt) {
                        if (!self.isJumping) {
                            if (self.canJump == true) {
                                self.isJumping = true;
                                self.jumpSpeed = self.jumpHeight;
                                self.isOnGround = false;
                            }
                        }
                    });
                    //A
                    document.querySelector('#right-controller').addEventListener('abuttondown', function(evt) {
                        if (!self.isJumping) {
                            if (self.canJump == true) {
                                self.isJumping = true;
                                self.jumpSpeed = self.jumpHeight;
                                self.isOnGround = false;
                            }
                        }
                    });

                    //                      window.addEventListener('keydown', (event) => {
                    //                          if (event.key === ' ' && !this.isJumping) {
                    //                              if (this.canJump == true) {
                    //                                  this.isJumping = true;
                    //                                  this.jumpSpeed = this.jumpHeight;
                    //                                  this.isOnGround = false;
                    //                              }
                    //                          }
                    //                      });

                }, updateGrounds: function() {
                    this.grounds = Array.from(document.querySelectorAll(this.data.groundSelector));
                },
                tick: function () {
                    const currentPosition = this.player.object3D.position;
                    let lowY, highY;
                    //see if we're over/under any platforms excluding playheads
                    this.groundCheck = Array.from(this.grounds).reduce((result, ground) => {

                        halfGroundX = ground.getAttribute("width") / 2;
                        halfGroundZ = ground.getAttribute("depth") / 2;
                        groundPosition = ground.getAttribute("position");
                        groundY = parseFloat(ground.getAttribute("height"));
                        newYLevel = groundY+groundPosition.y;  

                        const isOverGround = currentPosition.x >= groundPosition.x - halfGroundX &&
                              currentPosition.x <= groundPosition.x + halfGroundX &&
                              currentPosition.z >= groundPosition.z - halfGroundZ &&
                              currentPosition.z <= groundPosition.z + halfGroundZ;

                        if (isOverGround && halfGroundX === result.halfGroundX && halfGroundZ === result.halfGroundZ) {
                            if (ground.id !== "playhead") {
                                if (newYLevel < result.lowY) {
                                    result.lowY = newYLevel;
                                }
                                if (newYLevel > result.highY) {
                                    result.highY = newYLevel;
                                }
                            }
                            return result;
                        } else if (isOverGround) {
                            return {
                                isOverGround: true,
                                groundY: newYLevel,
                                halfGroundX: halfGroundX, 
                                halfGroundZ: halfGroundZ,
                                lowY: newYLevel,
                                highY: (ground.id === "playhead") ? 0 : newYLevel
                            };
                        } else {
                            return result;
                        }
                    }, { isOverGround: false, groundY: 0, halfGroundX: 0, halfGroundZ: 0, lowY: 0, highY: 0 });

                    if (!this.isJumping && this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY  ) {
                        this.isOnGround = true;
                    } else {
                        this.isOnGround = false;
                    }
                    if (this.isOnGround && !this.isJumping) {
                        this.canJump = true;
                    }

                    //send our values for sound
                    if (this.isJumping !== this.prevIsJumping || this.groundCheck.isOverGround !== this.groundCheck.prevIsOverGround) {
                        this.prevIsJumping = this.isJumping;
                        this.groundCheck.prevIsOverGround = this.groundCheck.isOverGround;
                        this.el.emit('state-changed', {isJumping: this.isJumping, isOverGround: this.groundCheck.isOverGround});
                    }
                    //gotta jump up jump up to get down
                    if (this.isJumping) {

                        this.jumpSpeed -= 0.01;
                        const newY = Math.max(currentPosition.y + this.jumpSpeed,this.groundCheck.lowY);

                        let clamp;
                        if(newY >= this.groundCheck.lowY && newY <= this.groundCheck.highY){
                            this.jumpSpeed -=0.01;
                            clamp = Math.max(newY, this.groundCheck.lowY);  
                        } else 
                            if(newY >= this.groundCheck.highY){
                                clamp = Math.max(newY,this.groundCheck.highY);   
                            }
                        this.player.object3D.position.set(currentPosition.x, clamp+0.1, currentPosition.z);

                        if (this.jumpSpeed <= -this.fallSpeed) {
                            this.isJumping = false;
                        }
                    } 
                    //so we can land on other platforms jumping from a different height
                    else if(this.groundCheck.isOverGround && currentPosition.y >= this.groundCheck.groundY-0.6|| !this.groundCheck.isOverGround && currentPosition.y > this.groundCheck.lowY){
                        this.jumpSpeed = 0.;
                        let fall = -0.5;

                        if(currentPosition.y >= this.groundCheck.highY){
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.highY);
                            const clamped = Math.max(newY,this.groundCheck.lowY);
                            this.player.object3D.position.set(currentPosition.x, clamped, currentPosition.z);
                            this.canJump = true; 
                            this.jumpSpeed = this.jumpHeight;
                        } else {
                            const newY = Math.max(currentPosition.y + this.jumpSpeed+fall,this.groundCheck.lowY);
                            //const clamped = Math.max(newY,this.groundCheck.lowY);
                            this.player.object3D.position.set(currentPosition.x, newY, currentPosition.z);
                            this.canJump = true; 
                            this.jumpSpeed =this.jumpHeight;
                        }
                    }
                    //fall off the edge
                    else if(!this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall;
                        this.player.object3D.position.set(currentPosition.x, newY, currentPosition.z);
                        this.canJump = false;
                    }
                    //get rid of the hang if player moves back under ground to trigger is overground bool
                    else if(this.groundCheck.isOverGround && currentPosition.y <= this.groundCheck.lowY){
                        let fall = -0.5;
                        const newY = currentPosition.y + fall
                        this.player.object3D.position.set(currentPosition.x,newY, currentPosition.z);
                        this.canJump = false;
                    }
                    //reset the player if they fall too far
                    if(currentPosition.y <= -82){
                        //make sure y is platformSize innit
                        this.player.object3D.position.set(0, 2, 8);
                    }
                },
            });
        </script>
        <!-- my everything collider -->
        <script>AFRAME.registerComponent("box-collider", {
                schema: {
                    hasBonked: { type: 'boolean', default: false }
                },
                init: function () {
                    this.player = document.querySelector("#player");
                    this.collected = false;
                    this.hasBonked = false;
                    this.hasEnded = false;
                    this.distanceThreshold = 4.51;

                },
                tick: function () {
                    this.player = document.querySelector("#player");
                    const playerPos = new THREE.Vector3();
                    const playerObj3D = this.player.object3D;
                    playerObj3D.getWorldPosition(playerPos);

                    const playerScale = this.player.getAttribute("scale");
                    const boxPos = this.el.object3D.position;
                    const bosRot = this.el.object3D.rotation;
                    const boxID = this.el.getAttribute("id");
                    const boxScale = this.el.getAttribute("scale");

                    const distance = playerPos.distanceTo(boxPos);

                    //check for collisions within the distance threshold
                    if (distance <= this.distanceThreshold) {

                        const halfWidthBox = 0.5 * parseFloat(this.el.getAttribute("width"));
                        const halfHeightBox = 0.5 * parseFloat(this.el.getAttribute("height"));
                        const halfDepthBox = 0.5 * parseFloat(this.el.getAttribute("depth"));

                        const halfWidthPlayer = 0.5 * parseFloat(this.player.getAttribute("width"));
                        const halfHeightPlayer = 0.5 * parseFloat(this.player.getAttribute("height"));
                        const halfDepthPlayer = 0.5  * parseFloat(this.player.getAttribute("depth"));

                        //distances
                        const dx = playerPos.x - boxPos.x;
                        const dy = playerPos.y - boxPos.y;
                        const dz = playerPos.z - boxPos.z;
                        //take the right face
                        const overlapX = halfWidthBox + halfWidthPlayer - Math.abs(dx);
                        const overlapY = halfHeightBox + halfHeightPlayer - Math.abs(dy);
                        const overlapZ = halfDepthBox + halfDepthPlayer - Math.abs(dz);

                        if (overlapX > 0 && overlapY >= 0 && overlapZ > 0) {
                            const minOverlap = Math.min(overlapX, overlapY, overlapZ);
                            if (minOverlap === overlapX) {
                                if(dx > 0){
                                    this.handleCollision(boxID, "x", halfWidthBox, halfWidthPlayer, boxPos.x, playerPos);
                                } 
                                else {
                                    this.handleCollision(boxID, "-x", halfWidthBox, halfWidthPlayer, boxPos.x, playerPos);
                                }
                            } else if (minOverlap === overlapY) {
                                if(dy > 0){
                                    this.handleCollision(boxID, "y", halfHeightBox, halfHeightPlayer, boxPos.y, playerPos);
                                }
                                else {
                                    this.handleCollision(boxID, "-y", halfHeightBox, halfHeightPlayer, boxPos.y, playerPos);
                                }
                            } else if (minOverlap === overlapZ) {
                                if(dz > 0) {
                                    this.handleCollision(boxID, "z", halfDepthBox, halfDepthPlayer, boxPos.z, playerPos);
                                }
                                else {
                                    this.handleCollision(boxID, "-z", halfDepthBox, halfDepthPlayer, boxPos.z, playerPos);
                                }
                            }
                        }
                    }
                },
                handleCollision: function(boxID, direction, halfBoxSize, halfPlayerSize, boxPos, playerPos) {
                    switch (boxID) {
                        case "platform":
                            if (direction === "x" || direction === "-x") {
                                playerPos.x = direction === "x" ? boxPos + halfBoxSize + halfPlayerSize+0.5 : boxPos - halfBoxSize - halfPlayerSize -0.5;
                            } else if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize +0.11: boxPos - halfBoxSize - halfPlayerSize ;
                            } else if (direction === "z" || direction === "-z") {
                                playerPos.z = direction === "z" ? boxPos + halfBoxSize + halfPlayerSize+0.5 : boxPos - halfBoxSize - halfPlayerSize - 0.5;
                            }
                            break;
                        case "playhead":
                            if (direction === "x" || direction === "-x") {
                                playerPos.x = direction === "x" ? boxPos + (halfBoxSize * 2) + halfPlayerSize + 3.1 : boxPos - (halfBoxSize * 2) - halfPlayerSize - 3.1;
                            } else if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            } else if (direction === "z" || direction === "-z") {
                                playerPos.z = direction === "z" ? boxPos + (halfBoxSize * 2) + halfPlayerSize + 3.1 : boxPos - (halfBoxSize * 2) - halfPlayerSize - 3.1;
                            }
                            this.hasBonked = true;
                            this.el.sceneEl.emit('bonked', { detail: { entity: this.el } });
                            break;
                        case "collectable":
                            this.collected = true;
                            this.el.emit('collected', { detail: {collected: this.collected}});
                            break;
                        case "lurker":
                            this.hasEnded = true;
                            this.el.sceneEl.emit('hasEnded', {detail: {hasEnded: this.hasEnded}});
                            if (direction === "y" || direction === "-y") {
                                playerPos.y = direction === "y" ? boxPos + halfBoxSize + halfPlayerSize : boxPos - halfBoxSize - halfPlayerSize;
                            }
                            break;
                    }
                    this.player.object3D.position.copy(playerPos);
                },
            });</script>
        <!-- Lurking end -->
        <script>AFRAME.registerComponent("lurker", {
                schema: {
                    target: { type: "selector" },
                    easingFactor: { type: "number", default: 0.03 },
                    offset: { type: "number", default: 0 },
                },
                init: function () {
                    //initial y position
                    this.initialY = this.el.object3D.position.y;
                    //player being targeted
                    this.targetWorldPosition = new THREE.Vector3();
                    this.offsetVector = new THREE.Vector3();
                },
                tick: function () {
                    //world position
                    this.data.target.object3D.getWorldPosition(this.targetWorldPosition);
                    //players rotation
                    const targetRotation = this.data.target.object3D.rotation;
                    //offset position
                    this.offsetVector.set(
                        -Math.sin(targetRotation.y) * this.data.offset,
                        0,
                        -Math.cos(targetRotation.y) * this.data.offset
                    );
                    //easing to x and z positions with the offset
                    this.el.object3D.position.x +=
                        (this.targetWorldPosition.x + this.offsetVector.x - this.el.object3D.position.x) * this.data.easingFactor;
                    this.el.object3D.position.z +=
                        (this.targetWorldPosition.z + this.offsetVector.z - this.el.object3D.position.z) * this.data.easingFactor;
                    //lockY
                    this.el.object3D.position.y = this.initialY;
                },
            });
        </script>
        <script>AFRAME.registerComponent('follow-rotation', {
                schema: {
                    target: {type: 'selector'},
                },
                tick: function () {
                    this.el.object3D.rotation.y = this.data.target.object3D.rotation.y;
                }
            });
        </script>    	    
    </head>
    <body>
        <div id="title">
        <h1>Red is Dead (B)</h1>
        </div>
        <div id="mySceneContainer">
        <a-scene embedded background="color: #005AFF">
                <!--vr controllers -->
                <a-entity id="left-controller" oculus-touch-controls="hand: left" model="false" controller></a-entity>
                <a-entity id="right-controller" oculus-touch-controls="hand: right" model="false" controller></a-entity>
                <!--this is where the magic happens-->
                <a-entity class="ground" id="platformsEntity"></a-entity> 
                <!--vr camera/player/rig -->
                <a-entity id="rig" position="0 0 0" >
                    <a-entity id="player" position="0 1.6 6" width="1" height="1.6" depth="1" jump>
                        <a-camera id="camera" camera ></a-camera>
                    </a-entity>
                </a-entity> 
                <!--to calculate heading angle for platforms when VR cam-->
                <a-entity id="directionEntity" follow-rotation="target: #camera;"></a-entity>
                <!--<a-entity id="player" camera position="0 2 8"width="1.0" height="2"depth="1" look-controls wasd-controls="acceleration: 60" jump></a-entity>-->
                <!--redkillplane -->
                <a-plane id="killplane" side="double" position="0 -26 0" rotation="-90 0 0" width="500" height="500" color="red"></a-plane>
                <!--start point-->
                <a-box class="ground" id="start" position="0 -1 6" width="6" height="1" depth="6" color="white"></a-box>
                <!--end point-->
                <a-box class='end' id="lurker" position="0 48 -15" width="4" height="0.25" depth="4" color="black" box-collider lurker="target: #player "></a-box>  
            </a-scene> 
        </div>
        <div class="container">
            <h3>Make sure your sound is turned up, nice and loud! It is in an experimental stage so expect the odd glitch or bug or slowdown every now and then. Give it a refresh if it's being very badly behaved. This only works in VR mode with controllers!</h3>
            <h3>Controls</h3>
            <div>
                <li>Thumbsticks + facing direction = forward</li>
                <li>X or A = jump</li>
            </div>
            <h3>Game info</h3>
            <div>
                The aim of the game is to navigate from your starting position to an end goal - a black platform that is above you. To do so, you collect orange tokens, which are used to generate new platforms.
            </div>
            <div>
                All you have to do is collect the tokens and avoid the red playheads. The token placement will happen when you pick them up.
            </div>
            <div id="dis">If you are uncomfortable with answering the questions, you are free to exit at anytime. If you feel dizzy or unwell please do stop. 
            </div>    
	    <div id="top" style="text-align: center;" id="top"><a href="https://forms.gle/3RRJ9w81Kr4TBu4V9"><a></div><br>
            <div id="gdpr">
            <div style="text-align: center;" id="top">
                <div>Thank you for playing both of the games! :)</div>
            </div>  
            </div>
            <div id="foot" style="text-align: center;">Alexander Brigden, Goldsmiths, University of London
            </div>
        </div>
        <script>
            let tempo = 96;
            let enemySynth;
            let backingMidSynth;
            let bassSynth;
            let sampler; 
            let staging = 0;
            let soundUP = false;
            let readyToPlay= true;
            //we jammin, and i hope you like jammin too
            var dm79 = [50, 57, 64, 65, 72];
            var eb911 = [51, 58, 65, 67, 69];
            var a7sus4 = [45, 57, 64, 67,47];
            var cadd9 = [48, 62, 64, 67, 72];

            var midSynthSeq = [
                //start, length, pitches
                {s:0, l:8, p:dm79},
                {s:16, l:8, p:eb911},
                {s:32, l:8, p:a7sus4},
                {s:48, l:8, p:cadd9},
            ];
            var bassSynthSeq = [ {s:0, l:16, p:38}];
            var bassSynthSeq2 = [
                {s:0, l:14, p:38},
                {s:15, l:6, p:37},
                {s:23, l:5, p:41},
                {s:29, l:2, p:43},
                {s:32, l:14, p:38},
                {s:47, l:6, p:37},
                {s:55, l:4, p:33},
                {s:59, l:2, p:33},
                {s:61, l:1, p:35},
            ];
            let myDrumSequence = [
                //                {p:4, s:0, v:10},
                //                {p:4, s:4, v:20},
                //                {p:4, s:8, v:40},
                //                {p:4, s:12, v:60}
            ];
            let myRhythm = [
                {p:2, s:2, v:100},
                {p:2, s:5, v:100},
                {p:2, s:8, v:100},
                {p:2, s:10, v:100},
                {p:2, s:11, v:100},
                {p:0, s:0, v:100},
                {p:1, s:12, v:100},
                {p:1, s:4, v:100},
                {p:0, s:10, v:100},
                {p:3, s:9, v:100},
                {p:3, s:4, v:100},
                {p:3, s:1, v:100},
                {p:0, s:14, v:100},
                {p:1, s:15, v:100},
                {p:3, s:15, v:100},
            ];
            let rhythmCounter = 0;

            // make clear that the origin is on mimicproject
            var origin = "https://mimicproject.com/libs";
            // pass the origin in when loading your instruments
            const instruments = new MaxiInstruments(origin);
            let scene = document.querySelector('a-scene');
            let player= document.getElementById('player');
          let directionEntity = document.querySelector("#directionEntity");
            const star = document.getElementById('start');
            let platformsEntity = document.getElementById('platformsEntity');
            let destroyStep = false;
            let platforms = [];
            let playheads = [];
            const platformPool = [];
            const MAX_PLATFORMS = 480;
            const playheadsPool = [];
            const MAX_PLAYHEADS = 30;
            let collectables = [];
            let stepSequenceLength = 16;
            let stepOffset = 0;
            let stepCheck = 0;
            let branchID = 0;
            let currentBranch = 0;
            let platformSize = 3;
            let previousOrientation = '-z';
            let metro = 0;
            let lastEventFixer = -1;
            let eventChangeCounter = 0;
            let collectableCount = 0;
            let collectablesFound = 0;
            let collectablePicked = false;
            let checked = false;
            let difficulty = 0;
            let eventFixer = 0;
            let keyPressed='';
            let ins = -1;
            let hasEnded = false;
            let canStart = false;
            let isJumping = false;
            let isOverGround = true;
            let currentPlayerStep;
            let sequenceTrigger = false;
            var selector = -1;
            let sequenceOrder = [-1];
            let playerSteps = [];
            let totalSteps = 0;
            let kicks = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let snares= [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let hihats= [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let bells = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];
            let isLoaded = false;
            //things that trigger sound
            let hasBonked = false;
            let bonking = 0;
            let activeNote = null;
            let pauseBonk = false;
            //bonk notes
            let notes = [62, 64, 65, 69 ];
            let reverb = 0;
            let roomSize = 0;
            let filter = 0.1;

            //initialize platform pool
            for(let i = 0; i < MAX_PLATFORMS; i++){
                let platform = document.createElement('a-box');
                platform.setAttribute('box-collider', '');
                platform.setAttribute('class', 'ground');
                platform.setAttribute('id', 'platform');
                platform.setAttribute('scale', {x: 1, y: 0.98, z:1});
                platform.setAttribute("visible", "false");
                platformPool.push(platform);
            }
            //initialise playhead pool
            for (let i = 0; i < MAX_PLAYHEADS; i++) {
                let playhead = document.createElement('a-box');
                playhead.setAttribute("box-collider", '');
                playhead.setAttribute('class', 'playheads');
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute('material', { color: 'red', transparent: 'true', opacity: '0.5' });
                playhead.setAttribute('side', 'double');
                playhead.setAttribute('width', platformSize - 0.1);
                playhead.setAttribute("height", platformSize - 0.1);
                playhead.setAttribute("depth", platformSize - 0.1);
                playhead.setAttribute('position', {x: 0, y:0, z:0});
                playhead.setAttribute('scale', {x: 1, y: 0.98, z:1});
                playhead.setAttribute("visible", "false"); 
                playheadsPool.push(playhead);
            }
            function getPlayhead() {
                for (let i = 0; i < playheadsPool.length; i++) {
                    if (!playheadsPool[i].getAttribute("visible")) {
                        return playheadsPool[i];
                    }
                }
                // if no available playhead found
                let playhead = document.createElement('a-box');
                playhead.setAttribute("box-collider", '');
                playhead.setAttribute('class', 'playheads');
                playhead.setAttribute('material', { color: 'red', transparent: 'true', opacity: '0.5' });
                playhead.setAttribute('side', 'double');
                playhead.setAttribute('width', platformSize - 0.1);
                playhead.setAttribute("height", platformSize - 0.1);
                playhead.setAttribute("depth", platformSize - 0.1);
                playhead.setAttribute('scale', {x: 1, y: 0.98, z:1});
                playhead.setAttribute("visible", "false"); 
                platformsEntity.appendChild(playhead);
                playheadsPool.push(playhead);
                return playhead;
            }
            //initialise our first platforms
            function startup(){
                canStart = false;
                //create the first sequence of platforms
                for(let i = stepSequenceLength-1; i >= 0 ; i--){
                    let platform = platformPool[i];  // Get a platform from the pool

                    let calc = Math.round(Math.abs((255/16) *i));
                    let rgbString = `rgb(${calc}, ${calc}, ${calc})`;
                    // set material color directly before the entity is attached to the scene
                    platform.setAttribute('material', 'color', rgbString);
                    platform.setAttribute('position', {x: 0, y: 0, z: -i*platformSize});
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute("visible", 'true');

                    platforms.push({p: platform, s: 15-i, o: stepOffset, branch: branchID, sound: 'tick', orientation: '-z'});
                    platformsEntity.appendChild(platform);
                }
                //make platform 1 a bit snazzier
                platforms[0].p.setAttribute('width', platformSize*3);
                platforms[0].p.setAttribute('height', platformSize-0.1);
                platforms[0].p.setAttribute('depth', platformSize*3);

                //get first playhead for platforms
                let playhead = getPlayhead();
                playhead.setAttribute('position', { x: 0, y: platformSize + 0.01, z: 0 });
                playhead.setAttribute('class', 'playheads');
                playhead.setAttribute("box-collider", '');
                playhead.setAttribute('id', 'playhead');
                playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                playhead.setAttribute('side', 'double');
                playhead.setAttribute('scale', {x: 1, y: 1, z:1});
                playhead.setAttribute('visible', 'true');
                playheads.push({p: playhead, o: '-z',startX: 0 , startZ: 0, modDel: 0});
                platformsEntity.appendChild(playhead);

                //create the first collectable
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('position', {x: 0, y: platformSize, z: -platformSize*(stepSequenceLength-1)});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', platformSize / 6);
                collectable.setAttribute("height", platformSize / 6);
                collectable.setAttribute("depth", platformSize / 6);
                collectable.setAttribute("box-collider", '');
                collectables.push(collectable);
                platformsEntity.appendChild(collectable);  
                onNewEntityAdded(collectable);
            };
            startup();
            //append the platform with everything a single platform needs
            scene.appendChild(platformsEntity);
            //don't run script until we have a scene!
            if (scene.hasLoaded) {
                run();
            } else {
                scene.addEventListener('loaded', run);
            }

            let rightController = document.querySelector('#right-controller');
            let leftController = document.querySelector('#left-controller');

            //right controller
            rightController.addEventListener('abuttondown', function(evt) { handleButtonPress(evt); });
            //rightController.addEventListener('abuttonup', function(evt) {  });
            rightController.addEventListener('bbuttondown', function(evt) { handleButtonPress(evt); });
            //             rightController.addEventListener('bbuttonup', function(evt) { });
            rightController.addEventListener('righttriggerdown', function(evt) { handleButtonPress(evt); });
            //             rightController.addEventListener('righttriggerup', function(evt) {  });
            rightController.addEventListener('rightgripdown', function(evt) { handleButtonPress(evt); });
            rightController.addEventListener('rightgripup', function(evt) {  });

            //left controller
            leftController.addEventListener('xbuttondown', function(evt) { handleButtonPress(evt); });
            //leftController.addEventListener('xbuttonup', function(evt) {  });
            leftController.addEventListener('ybuttondown', function(evt) { handleButtonPress(evt); });
            //             leftController.addEventListener('ybuttonup', function(evt) { });
            leftController.addEventListener('lefttriggerdown', function(evt) { handleButtonPress(evt); });
            //             leftController.addEventListener('lefttriggerup', function(evt) {  });
            leftController.addEventListener('leftgripdown', function(evt) { handleButtonPress(evt); });
            //             leftController.addEventListener('leftgripup', function(evt) { });
            //first button presson only
            function handleButtonPress(evt) {
                if (soundUP == false) {                 
                    playSomething();    
                    soundUP = true;
                }
            }    

            //have we collected collectable? 
            function logCollected(event) {
                const collectable = document.getElementById('collectable');
                collectableCount += 1;
                collectablesFound += 1;
                collectablePicked = true;
                checked = true;
                for(let i = 0; i < collectables.length; i++){   
                    collectables.splice(i,1);
                    platformsEntity.removeChild(collectable);
                }
            };
            function setupEventListener(entity) {
                // Remove any old event listeners
                entity.removeEventListener('collected', logCollected);
                // Add a new event listener
                entity.addEventListener('collected', logCollected);
            };
            document.addEventListener('DOMContentLoaded', () => {
                const entity = document.querySelector('#collectable');
                setupEventListener(entity);
            });
            //add event listener for new collectable
            function onNewEntityAdded(entity) {
                setupEventListener(entity);
            };
            //check if we're jump and overground for collectible use
            document.addEventListener('DOMContentLoaded', function() {
                let player = document.querySelector('#player');
                player.addEventListener('state-changed', function(event) {
                    isJumping = event.detail.isJumping;
                    isOverGround = event.detail.isOverGround;
                });
            });
            //playhead collision
            document.addEventListener('DOMContentLoaded', function () {
                //get the scene
                const scene = document.querySelector('a-scene');
                //event listener for the 'bonked' event
                scene.addEventListener('bonked', function (event) {
                    hasBonked = true;
                });
                scene.addEventListener('hasEnded', function (event){

                    // use the boolean value as needed
                    hasEnded = true;
                })
            });
            //which direction are we facing
            function headingDirection(camera) {
                let direction = new THREE.Vector3();
                camera.object3D.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                // Calculate heading in degrees, adjusted for three.js's coordinate system
                let heading = Math.atan2(direction.x, direction.z) * 180 / Math.PI;
                // Normalize heading to be between 0 and 360
                heading = (heading + 360) % 360;

                let facing = "";
                if (heading >= 0 && heading <= 45 || heading > 315 && heading < 360) {
                    facing = "northWest";
                } else if (heading > 45 && heading <= 90) {
                    facing = "westNorth";
                } else if (heading > 90 && heading <= 135) {
                    facing = "westSouth";
                } else if (heading > 135 && heading <= 180) {
                    facing = "southWest";
                } else if (heading > 180 && heading <= 225) {
                    facing = "southEast";
                } else if (heading > 225 && heading <= 270) {
                    facing = "eastSouth";
                } else if (heading > 270 && heading <= 315) {
                    facing = "eastNorth";
                }
                return facing;
            };
            //spend collectables (to generate platforms)
            function useCollectables(player, facing, inputs) {
                const playerPos = player.getAttribute('position');

                if (collectableCount <= 0 ) {
                    return;
                }
                const validInputs = [0, 1, 2, 3];
                if (!validInputs.includes(inputs)) {
                    return;
                }
                const directions = {
                    northWest: { x: '-x', z: '-z' },
                    westNorth: { x: '-x', z: '-z' },
                    westSouth: { x: '-x', z: 'z' },
                    southWest: { x: '-x', z: 'z' },
                    southEast: { x: 'x', z: 'z' },
                    eastSouth: { x: 'x', z: 'z' },
                    eastNorth: { x: 'x', z: '-z' },
                    northEast: { x: 'x', z: '-z' },
                };
                const direction = directions[facing];

                if (!direction) {
                    return;
                }

                let newOrientation;
                if (previousOrientation === 'z' || previousOrientation === '-z') {
                    newOrientation = (direction.x === 'x' || direction.x === '-x') ? direction.x : direction.z;
                } else {
                    newOrientation = (direction.z === 'z' || direction.z === '-z') ? direction.z : direction.x;
                }
                //                /stepSequencer();
                generatePlatforms(playerPos, stepSequenceLength, selector, newOrientation);
                previousOrientation = newOrientation;

            };
            //we move this shit
            function movePlayheads() {
                const reverseOffset = (stepSequenceLength-0.5) * platformSize;

                for (let i = 0; i < playheads.length; i++) {
                    let modMetro = -(metro - playheads[i].modDel) % stepSequenceLength;

                    const playheadPos = playheads[i].p.getAttribute('position');
                    const playheadSize = parseFloat(playheads[i].p.getAttribute('width'));

                    let normalisedStart, difference, newPosition;

                    if (playheads[i].o == "-z" || playheads[i].o == "z") {
                        normalisedStart = (Math.abs(playheads[i].startX) / platformSize);
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newZ = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheadPos.x,
                            y: playheadPos.y,
                            z: playheads[i].o == "-z"
                            ? playheads[i].startZ + newZ - reverseOffset
                            : playheads[i].startZ - newZ + reverseOffset
                        };
                    } else {
                        normalisedStart = (Math.abs(playheads[i].startZ) / platformSize) % stepSequenceLength;
                        difference = stepSequenceLength - normalisedStart - stepSequenceLength;
                        const newX = -((modMetro + difference) % stepSequenceLength) * platformSize;
                        newPosition = {
                            x: playheads[i].o == "-x"
                            ? playheads[i].startX + newX - reverseOffset
                            : playheads[i].startX - newX + reverseOffset,
                            y: playheadPos.y,
                            z: playheadPos.z
                        };
                    }

                    playheads[i].p.setAttribute('position', newPosition);
                }
            };   
            function generatePlatforms(playerPos, numSteps, inputs, orientation){

                //make sure we turn off our collectable
                collectableCount--;
                difficultyMapper();

                //floor playerX and Z so we don't prematurely slide off of platform edge
                let playerFlooredX = Math.floor(0.5+(playerPos.x)/platformSize)*platformSize;
                let playerFlooredZ = Math.floor(0.5+(playerPos.z)/platformSize)*platformSize;

                //update the offset for our step sequencer based on what platform we are over when we generate new ones. 
                stepOffset = ((stepOffset + stepCheck)%16);
                //increment placementID - this is used so we can keep track of which platforms relate to which placement (useful for deletion)
                branchID = branchID + 1;

                //change colour of platforms based on input type
                r = 255;
                g = 255;
                b = 255;

                let platformLabel;

                switch (inputs) {
                    case 0:
                        platformLabel = 'kicks';
                        r = 255;
                        g = 165;
                        b = 0;
                        break;
                    case 1:
                        platformLabel = 'snares';
                        r = 255;
                        g = 210;
                        b = 128;
                        break;
                    case 2:
                        platformLabel = 'hihats';
                        r = 0;
                        g = 191;
                        b = 123;
                        break;
                    case 3:
                        platformLabel = 'bells';
                        r = 0;
                        g = 255;
                        b = 165;
                        break;
                    default:
                        break;
                }
                //grab some platforms from the pool
                for(let i = numSteps-1; i >= 0; i--){
                    let platform = null;
                    if (platformPool.length > 0) {
                        platform = platformPool.pop();  // Get a platform from the pool
                    } else {
                        // Create a new platform if pool is empty
                        platform = document.createElement('a-box');
                    }

                    platform.setAttribute('class', 'ground');
                    platform.setAttribute('box-collider', '');
                    platform.setAttribute('id', 'platform');  // give each platform a unique id
                    platform.setAttribute('width', platformSize);
                    platform.setAttribute("height", platformSize);
                    platform.setAttribute("depth", platformSize);
                    platform.setAttribute('scale',  {x: 1, y: 1, z: 1});
                    platform.setAttribute('box-collider', '');
                    platform.setAttribute('visible', 'true');

                    //colour the new platforms with a sick fade yo
                    calcR = r-Math.round(Math.abs((r/numSteps) *(i%numSteps)));
                    calcG = g-Math.round(Math.abs((g/numSteps) *(i%numSteps)));
                    calcB = b-Math.round(Math.abs((b/numSteps) *(i%numSteps))); 
                    let rgbString = `rgb(${calcR}, ${calcG}, ${calcB})`;
                    platform.setAttribute('material', 'color', rgbString);  

                    //set position based on player orientation
                    let position = {x: playerFlooredX, y: playerPos.y, z: playerFlooredZ};
                    let distance = i * platformSize;

                    switch (orientation) {
                        case '-x':
                        case 'x':
                            position.x += orientation === '-x' ? -distance : distance;
                            break;
                        case '-z':
                        case 'z':
                            position.z += orientation === '-z' ? -distance : distance;
                            break;
                    }
                    platform.object3D.position.set(position.x, position.y, position.z);

                    platforms.push({p:platform, s: 15-i, o: 0, branch: branchID, sound: platformLabel, orient: orientation});
                    platformsEntity.appendChild(platform);
                }

                //playhead biz
                let playhead = getPlayhead();
                if (playhead) {
                    playhead.setAttribute('class', 'playheads');
                    playhead.setAttribute("box-collider", '');
                    playhead.setAttribute('id', 'playhead');
                    playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                    playhead.setAttribute('side', 'double');
                    playhead.setAttribute('scale', {x: 1, y: 1, z:1});

                    //our kick PlayHeads
                    if(sequenceOrder[sequenceOrder.length-1] == 0){
                        playhead.setAttribute('width', 3* platformSize-0.1);
                        playhead.setAttribute("height", platformSize-0.1);
                        playhead.setAttribute("depth",3 * platformSize-0.1);
                    } 
                    else if(sequenceOrder[sequenceOrder.length-1] == 1){
                        playhead.setAttribute('width', (platformSize-0.1)/2);
                        playhead.setAttribute("height",(platformSize-0.1)*3);
                        playhead.setAttribute("depth", (platformSize-0.1)/2);
                    } 
                    else if(sequenceOrder[sequenceOrder.length-1] == 2){
                        if (orientation == 'x' || orientation == '-x'){
                            playhead.setAttribute('width', (platformSize-0.1)*4);
                            playhead.setAttribute("height",(platformSize-0.1)/4);
                            playhead.setAttribute("depth", (platformSize-0.1)/4);   
                        } else {
                            playhead.setAttribute('width', (platformSize-0.1)/4);
                            playhead.setAttribute("height",(platformSize-0.1)/4);
                            playhead.setAttribute("depth", (platformSize-0.1)*4);     
                        }
                    } 
                    else{
                        if (orientation == 'x' || orientation == '-x'){
                            playhead.setAttribute('width', (platformSize-0.1));
                            playhead.setAttribute("height",(platformSize-0.1)/4);
                            playhead.setAttribute("depth", (platformSize-0.1)*3);   
                        } else {
                            playhead.setAttribute('width', (platformSize-0.1)*3);
                            playhead.setAttribute("height",(platformSize-0.1)/4);
                            playhead.setAttribute("depth", (platformSize-0.1));     
                        }
                    } 

                    let newPosition = { x: playerFlooredX, y: playerPos.y + platformSize + 0.001, z: playerFlooredZ };
                    playhead.setAttribute('position', newPosition);

                    let playheadData = {
                        p: playhead,
                        o: orientation,
                        startX: playerFlooredX,
                        startZ: playerFlooredZ,
                        modDel: stepOffset - currentPlayerStep,
                    };
                    playheads.push(playheadData);
                    playhead.setAttribute('visible', 'true');
                } else {
                    playhead = document.createElement('a-box');
                    playhead.setAttribute('class', 'playheads');
                    playhead.setAttribute('id', 'playhead');
                    playhead.setAttribute('material', {color: 'red', transparent: 'true', opacity: '0.5'});
                    playhead.setAttribute('side', 'double');
                    playhead.setAttribute('scale', {x: 1, y: 0.98, z:1});
                    playhead.setAttribute('visible', 'false');
                    playheadsPool.push(playhead);
                    platformsEntity.appendChild(playhead);   
                }
                //wait so our platforms positions are updated and then place collectable

                //generate the collectable for that platform
                let collectable = document.createElement('a-box');
                collectable.setAttribute('id', 'collectable');
                collectable.setAttribute('material', {color: 'rgb(255,165,0)'});
                collectable.setAttribute('rotation', {x: 45, y: 45, z: 45});
                collectable.setAttribute('width', platformSize/6);
                collectable.setAttribute("height", platformSize/6);
                collectable.setAttribute("depth", platformSize/6);
                collectable.setAttribute("box-collider", '');

                //quick and dirty as main way is fucked/too computational expensive
                let away = myRhythm[rhythmCounter].s;

                if(orientation == '-x'){
                    //ofset the x by the negative of sequence so it places it at the end
                    collectable.setAttribute('position', {x: playerFlooredX -((away)*platformSize), y: platformSize+playerPos.y, z:playerFlooredZ});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == '-z'){      
                    collectable.setAttribute('position', {x: playerFlooredX, y: platformSize+playerPos.y, z:playerFlooredZ-((away)*platformSize)});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == 'z'){
                    collectable.setAttribute('position', {x: playerFlooredX, y: platformSize+playerPos.y, z:playerFlooredZ+((away)*platformSize)});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize , z: place.z})
                }
                else if(orientation == 'x'){
                    collectable.setAttribute('position', {x: playerFlooredX +((away)*platformSize), y: platformSize+playerPos.y, z:playerFlooredZ});
                    //collectable.setAttribute('position', {x: place.x, y: place.y + platformSize, z: place.z})
                }
                collectables.push(collectable);
                //append to entity in scene
                platformsEntity.appendChild(collectable);
                onNewEntityAdded(collectable);

                //replace our player so they don't get stuck inside the new dropped platform
                player.setAttribute('position', {x: playerPos.x, y: playerPos.y + (platformSize*3)+0.1, z: playerPos.z});

            };
            // use step check and inputs to trigger sound / add them to instrument array 
            function stepSequencer(player) {
                //                const playerPos = player.getAttribute('position');
                //                const playerX = playerPos.x;
                //                const playerY = playerPos.y;
                //                const playerZ = playerPos.z;
                //                const halfPlatformSize = platformSize / 2;
                //
                //                for (let i = 0; i < platforms.length; i++) {
                //                    const platformPos = platforms[i].p.getAttribute('position');
                //                    const platformX = platformPos.x;
                //                    const platformY = platformPos.y;
                //                    const platformZ = platformPos.z;
                //
                //                    if (
                //                        playerX > platformX - halfPlatformSize &&
                //                        playerX < platformX + halfPlatformSize &&
                //                        playerY >= platformY &&
                //                        playerY <= platformY + (platformSize + 1.1) &&
                //                        playerZ > platformZ - halfPlatformSize &&
                //                        playerZ < platformZ + halfPlatformSize
                //                    ) {
                //let standingStep = (platforms[i].s + platforms[i].o) % stepSequenceLength;
                stepCheck = myRhythm[rhythmCounter].s;
                currentPlayerStep = myRhythm[rhythmCounter].s;
                //currentBranch = platforms[i].branch;
                //                    }
                //                }

                if (collectableCount > 0 && checked == true) {
                    playerSteps.push(myRhythm[rhythmCounter].s);
                    myDrumSequence.push(myRhythm[rhythmCounter]);
                    sampler.setSequence(myDrumSequence, 4);
                    sequenceOrder.push(myRhythm[rhythmCounter].p);

                    selector = myRhythm[rhythmCounter].p;
                    rhythmCounter+=1;
                    if(rhythmCounter%15==0){
                        rhythmCounter = 0;
                    }
                    checked = false;
                    //console.log("playLen ", playerSteps.length, "myRhyC", rhythmCounter, "seqOrd", sequenceOrder.length, "selector ", selector, "my RHY STEP",myRhythm[rhythmCounter].s, "RHY P ", myRhythm[rhythmCounter].p );
                    useCollectables(player, headingDirection(directionEntity),selector);
                }
            };      
            //grab our sample triggers 
            function sequenceTracker(myDrumSequence) {
                for (let i = 0; i < myDrumSequence.length; i++) {
                    const drumItem = myDrumSequence[i];
                    const drumIndex = drumItem.s;

                    if (drumItem.v > 0) {
                        switch (drumItem.p) {
                            case 0:
                                kicks[drumIndex] = true;
                                break;
                            case 1:
                                snares[drumIndex] = true;
                                break;
                            case 2:
                                hihats[drumIndex] = true;
                                break;
                            case 3:
                                bells[drumIndex] = true;
                                break;
                        }
                    }
                }
            };
            //mapped our beats so we can check their distribution
            function mappedBar(bar) {
                //steps mapped
                const stepValues = bar.map((bool, index) => {
                    const mapping = [8, 1, 4, 2];
                    const mappingIndex = index % 4;
                    return bool ? mapping[mappingIndex] : 0;
                });
                // Beat values
                const beatValues = [];
                for (let i = 0; i < stepValues.length; i += 4) {
                    let sum = 0;
                    for (let j = i; j < i + 4; j++) {
                        sum += isNaN(stepValues[j]) ? 0 : stepValues[j];
                    }
                    beatValues.push(sum);
                }           
                return {stepValues, beatValues};
            }; 
            //nifty function for checking individual bar distribution
            function barCheck(beats){
                if(beats[0] > beats[1] && beats[2] & beats[3]){
                    return 5;
                }
                if(beats[1] > beats[0]&& beats[2] && beats[3]){
                    return 10;
                }
                if(beats[2] > beats[0]&& beats[1] && beats[3]){
                    return 5;
                }
                if(beats[3] > beats[0]&& beats[1] && beats[2]){
                    return 5;
                }  else {
                    return 0;
                } 
            };
            //nifty distance calc for how far things are from other things
            function distance3D(a, b) {
                return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow(a.z - b.z, 2));
            };
            //lil scale
            function scale (number, inMin, inMax, outMin, outMax) {
                return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
            };      
            //move our collectables around the steps environment based on step distribution
            function difficultyMapper(){
                //mapped bar returns 16 step Values mapped to 8, 1, 4, 2
                let mappedKicks = mappedBar(kicks);
                let mappedSnares = mappedBar(snares);
                let mappedHihats = mappedBar(hihats);
                let mappedBells = mappedBar(bells);
                let allKicksStepValues = mappedBar(kicks).stepValues;
                let allSnaresStepValues = mappedBar(snares).stepValues;
                let allHihatsStepValues = mappedBar(hihats).stepValues;
                let allBellsStepValues = mappedBar(bells).stepValues;
                let allKicksBeatValues = mappedBar(kicks).beatValues;
                let allSnaresBeatValues = mappedBar(snares).beatValues;
                let allHihatsBeatValues = mappedBar(hihats).beatValues;
                let allBellsBeatValues = mappedBar(bells).beatValues;
                //let difficulty = 0;
                //our distances so we know where we're mapping notes too
                let sumKicks = 0;
                let sumSnares = 0;
                let sumHihats = 0;
                let sumBells = 0;
                let sumAllSteps =[];
                //where to play then next collectable
                let collectablePlacement;
                //get sums of all our steps
                for(let i = 0; i < 16; i++){
                    sumKicks += allKicksStepValues[i];
                    sumSnares += allSnaresStepValues[i];
                    sumHihats += allHihatsStepValues[i];
                    sumBells += allBellsStepValues[i];
                    sumAllSteps.push(allKicksStepValues[i]+allSnaresStepValues[i]+allHihatsStepValues[i]+allBellsStepValues[i]);
                }
                //increase difficulty abit every collection
                for(let i = 0; i< collectablesFound; i++){
                    difficulty += 5;
                }
                //increase difficult based on kicks
                if(sumKicks > 12 && sumKicks <=18){
                    difficulty +=25;
                }
                //increase difficulty based on snares
                if(sumSnares > 12 && sumSnares <= 16 ){
                    difficulty +=25;
                } 
                else if (sumSnares > 16){
                    difficulty +=30;
                }
                //increase difficult based on hihats and bells
                if(sumHihats + sumBells > 20){
                    difficulty +=15;
                }
                //reward players if they can manage some parity between distributions
                if(allKicksBeatValues[0] > 0 && allKicksBeatValues[0] == allKicksBeatValues[1] && allKicksBeatValues[2] && allKicksBeatValues[3]){
                    difficulty -=15;
                } 
                if(allHihatsBeatValues[0] > 0 && allHihatsBeatValues[0] == allHihatsBeatValues[1] && allHihatsBeatValues[2] && allHihatsBeatValues[3] || allBellsBeatValues[0] > 0 && allBellsBeatValues[0] == allBellsBeatValues[1] && allBellsBeatValues[2] && allBellsBeatValues[3]){
                    difficulty -=20;
                }
                //when distribution is too lopsided make target location very far way. 
                difficulty = difficulty + barCheck(sumAllSteps);

            };
            //update our collectables / move them around in case one of them gets stuck
            function reorderSamples(sample, currentPlayerStep) {
                const reordered = [];
                for (let i = 0; i < 16; i++) {
                    reordered[i] = sample[(currentPlayerStep + 1 +  i) % 16];
                }
                return reordered;
            };      
            //helper to minimise setAttributes
            function updatePlatformAttributes(platform, width, height, depth) {
                platform.p.setAttribute('width', width);
                platform.p.setAttribute('height', height);
                platform.p.setAttribute('depth', depth);
                platform.p.setAttribute('scale', { x: 1, y: 0.98, z: 1 });
            };
            //update our platforms when we trigger the corresponding step yo
            function updatePlatforms() {

                let base = playerSteps.length * 16;
                //if (platform && platform.orientation) {

                // console.log("base ", base, "playerStepLEn ", playerSteps.length);
                let reorderedSamples;

                switch (selector) {
                    case 0:
                        reorderedSamples = reorderSamples(kicks, currentPlayerStep);
                        break;
                    case 1:
                        reorderedSamples = reorderSamples(snares, currentPlayerStep);
                        break;
                    case 2:
                        reorderedSamples = reorderSamples(hihats, currentPlayerStep);
                        break;
                    case 3:
                        reorderedSamples = reorderSamples(bells, currentPlayerStep);
                        break;
                    default:
                        return;
                }
                for (let i = 0; i < reorderedSamples.length; i++) {
                    if (reorderedSamples[i] === true) {

                        let platform = platforms[i + base];
                        //console.log("updating", platforms[i + base], "orientation = ", platforms[i+base].orientation);

                        switch (selector) {
                            case 0:
                                updatePlatformAttributes(platform, platformSize * 3, platformSize, platformSize * 3);
                                break;
                            case 1:
                                let width = (platform.orient == 'x' || platform.orient == '-x') ? platformSize * 2 : platformSize / 2;

                                let depth = (platform.orient == 'x' || platform.orient == '-x') ? platformSize / 2 : platformSize * 2;
                                updatePlatformAttributes(platform, width, platformSize * 3, depth);
                                break;
                            case 2:
                                let hatWidth = (platform.orient == 'x' || platform.orient == '-x') ? platformSize * 3 : platformSize / 2;
                                let hatDepth = (platform.orient == 'x' || platform.orient == '-x') ? platformSize / 2 : platformSize * 3;
                                updatePlatformAttributes(platform, hatWidth, platformSize / 4, hatDepth);
                                break;
                            case 3:
                                updatePlatformAttributes(platform, platformSize * 3, platformSize / 4, platformSize * 3);
                                break;
                        }
                        if (!platform.orient) {
                            console.error('Platform.orientation is undefined at index:', i + base);
                            continue;
                        }
                        //                    }
                        //                    else{
                        //    console.log('Platform or platform.orientation is undefined at index:', i + base);
                        //
                        //                }
                    } 
                }
                selector = -1;

            };
            //destroy our playforms if our players want to do that
            function destroyer(){
                const collectable = document.getElementById('collectable');
                if(destroyStep == true && currentBranch > 0){
                    for (let i = platforms.length - 1; i >= 0; i--) {
                        if (platforms[i].branch === currentBranch) {
                            platforms[i].p.remove();
                            platforms.splice(i, 1); 
                        }
                    }
                    collectableCount+=1;
                    playerSteps.splice(0,1);
                    platformsEntity.remove(collectable);
                    destroyStep = false;
                }
            };
            //this is where the real magic happens
            function updateSounds(){
                //have we been bonked by a playhead
                if(hasBonked == true){
                    let randomNote = notes[Math.floor(Math.random()*notes.length)];
                    enemySynth.noteon(randomNote, 127);
                    bonking = 1.0;
                    roomSize =1.0;
                    hasBonked = false;
                }

                if(bonking > 0){
                    bonking -= 0.1;
                    reverb += 0.2;
                    enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                }
                console.log("bonking", bonking);
                if (bonking  <= 0){

                    enemySynth.noteoff(62);
                    enemySynth.noteoff(64);
                    enemySynth.noteoff(65);
                    enemySynth.noteoff(69);

                    bonking = 0;
                    enemySynth.setParams(["delay", bonking], ["delayMix", 0.5 ],["reverbMix",reverb],["roomSize",roomSize],["gain",bonking],);
                } 

                //jump sounds
                if(isJumping == true){
                    filter += 0.5;  
                    backingMidSynth.setParam("lfoFrequency", filter);
                    backingMidSynth.setParam("lfoPitchMod", filter);
                    bassSynth.setParam("cutoff", filter *40);
                    sampler.setParam("rate_1", scale(filter, -2, 1, 0.1, 0.5)) ;
                    sampler.setParam("rate_2", filter+0.5);
                    sampler.setParam("rate_3", filter-0.5);
                } else {
                    if(filter > 0.11){
                        backingMidSynth.setParam("lfoFrequency", filter);
                        backingMidSynth.setParam("lfoPitchMod", filter);
                        backingMidSynth.setParam("lfoPitchMod", filter);  
                    }

                    filter = 0;
                } 
                //falling sounds
                let fall = player.getAttribute('position').y;
                if(fall < -2){
                    let drop = scale(fall,-30,0, 0.5, 0.1);
                    sampler.setParam("rate_0", drop);
                    sampler.setParam("rate_1", drop);
                    bassSynth.setParam("adsrPitchMod", drop*-1000);
                    bassSynth.setParam('cutoff', drop*-100);
                    bassSynth.setParam("lfoFrequency", 10-drop);
                    backingMidSynth.setParam("lfoFrequency", drop);
                    sampler.setParam("rate_4", drop);
                } 
                if(fall <= -70){
                    sampler.setParam("rate_0", 0.5);
                    sampler.setParam("rate_1", 0.5);
                    bassSynth.setParam("adsrPitchMod", 0);
                }

                //our arrangement for backing synths
                if(collectablesFound == 1 && collectablePicked == true){

                    bassSynth.setParam('gain', 1);
                    collectablePicked = false;

                }
                if(collectablesFound == 2 && collectablePicked == true){   
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;                        
                    }                    
                }
                if(collectablesFound == 3 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38},{s:4, l:4, p:36},{s:8, l:4, p:33}, {s:12, l:4, p:36}],2);
                        bassSynth.setLoop(16,4);
                        collectablePicked = false;    
                    }   
                }
                if(collectablesFound == 4 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind(); 
                        bassSynth.setSequence([{s:0, l:16, p:33}],1);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    }   
                }
                if(collectablesFound == 5 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:4, p:38}, {s:0, l:16, p:48}],4);
                        bassSynth.setLoop(16,1);
                        backingMidSynth.setLoop(64,4); 
                        collectablePicked = false;                        
                    } 
                }
                if(collectablesFound == 6 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:8, p:38},{s:8, l:4, p:48},{s:12, l:4, p:45}, {s:16, l:16, p:39}],4);
                        bassSynth.setLoop(32,4);
                        backingMidSynth.setSequence([{s:0, l:8, p:a7sus4},
                                                     {s:16, l:8, p:cadd9},
                                                    ],4);
                        backingMidSynth.setLoop(32,4); 
                        collectablePicked = false;    
                    } 
                }
                if(collectablesFound == 7 && collectablePicked == true){
                    if(sequenceTrigger == true){
                        instruments.rewind();
                        bassSynth.setSequence([{s:0, l:16, p:38}],1);
                        bassSynth.setLoop(32,4);
                        collectablePicked = false;    
                    }
                }

                //                enemySynth.getMappedParameters;
                //                backingMidSynth.getMappedParameters;
                //                bassSynth.getMappedParameters; 
                //                sampler.getMappedParameters;

            }; 
            //end game reset
            function end(){
                //sequentially do stuff
                if (eventFixer !== lastEventFixer) {
                    lastEventFixer = eventFixer;
                    eventChangeCounter+=0.5;
                }
                if (eventChangeCounter % 5 === 2) { 
                    scene.setAttribute('background',{color: 'black'});
                } 
                else if (eventChangeCounter % 5 === 3) {
                    killplane.setAttribute('color', 'black' );
                    for(let i = 0; i < platforms.length; i++){
                        platforms[i].p.remove();
                        platforms.splice(i, 1);
                        //platformsEntity.removeAll();
                    }
		    for(let i = 0; i < playheads.length; i++){
                        playheads[i].p.remove();
                        playheads.splice(i, 1);
                        //platformsEntity.removeAll();
                    }
			
                    collectables.splice(0, collectables.length);
                    platformsEntity.remove(collectable);
                } 
                else if (eventChangeCounter % 5 === 4) {
                    star.setAttribute('color', 'Black');
                    sampler.mute();
                    backingMidSynth.mute();
                    bassSynth.mute();
                    instruments.playPause();
                    instruments.rewind();
                } 
                else if (eventChangeCounter % 5 === 0 && eventChangeCounter !== 0) {
                    canStart = true;
                    hasEnded = false;
                }
            };
            //we pushin' speakers 
            const playSomething=()=>{
                instruments.loadModules().then(()=> {

                    enemySynth = instruments.addSynth();
                    backingMidSynth = instruments.addSynth();
                    bassSynth = instruments.addSynth();
                    backingMidSynth.setOsc(1);
                    bassSynth.setOsc(1);
                    enemySynth.setOsc(1);

                    backingMidSynth.setParams([
                        ["oscFn",3],
                        ["lfoOscFn",0],
                        ["gain",0.4],
                        ["pan",0.5],
                        ["attack",165],
                        ["decay",330],
                        ["sustain",0.58],
                        ["release",495],
                        ["lfoFrequency",0.7],
                        ["lfoPitchMod",0],
                        ["lfoFilterMod",1000],
                        ["lfoAmpMod",0.68],
                        ["adsrPitchMod",1],
                        ["cutoff",957.6],
                        ["reverbMix",0.33],
                        ["roomSize",0.27],
                        ["delay",0],
                        ["delayMix",0.35],
                        ["frequency",440],
                        ["frequency2",220],
                    ]);
                    enemySynth.setParams([
                        ["oscFn",3],
                        ["lfoOscFn",1],
                        ["gain",2],
                        ["pan",0.5],
                        ["attack",0],
                        ["decay",330],
                        ["sustain",0.1],
                        ["release",1500],
                        ["lfoFrequency",6.3],
                        ["lfoPitchMod",0],
                        ["lfoFilterMod",220],
                        ["lfoAmpMod",0.88],
                        ["adsrPitchMod",0],
                        ["cutoff",1372],
                        ["reverbMix",0.12],
                        ["roomSize",0],
                        ["delay",0],
                        ["delayMix",0],
                        ["frequency",440],
                        ["frequency2",220],
                    ]);
                    bassSynth.setParams([
                        ["oscFn",3],
                        ["lfoOscFn",1],
                        ["gain",0],
                        ["pan",0.53],
                        ["attack",1155],
                        ["decay",480],
                        ["sustain",0.58],
                        ["release",1185],
                        ["lfoFrequency",10],
                        ["lfoPitchMod",0],
                        ["lfoFilterMod",1000],
                        ["lfoAmpMod",0.78],
                        ["adsrPitchMod",1],
                        ["cutoff",40],
                        ["reverbMix",0],
                        ["roomSize",0],
                        ["delay",0],
                        ["delayMix",0.35],
                        ["frequency",440],
                        ["frequency2",220],
                    ]);

                    enemySynth.mapped = ["gain","reverbMix","roomSize", "delay","delayMix"];
                    backingMidSynth.mapped = ["gain", "lfoFrequency", "lfoPitchMod", "reverb"];
                    bassSynth.mapped = ["lfoFrequency", "pan", "cutoff" ,"adsrPitchMod", "frequency"];

                    sampler = instruments.addSampler();
                    sampler.loadSample("BD-ER1-CR8000ish.wav", 0);
                    sampler.loadSample("DR660SnareLofinice.wav", 1);
                    sampler.loadSample("TOM-ER-MicroTom2.wav", 2);
                    sampler.loadSample("FX-ER-Sonario.wav", 3);
                    sampler.loadSample("FX-ER1-Woodzblox.wav", 4);

                    sampler.setParam("rate_0", 1);
                    sampler.setParam("rate_1", 1);
                    sampler.setParam("rate_2", 1);
                    sampler.setParam("rate_3", 1);
                    sampler.setParam("rate_4", 1);
                    sampler.setParam("pan_0", 0.5);
                    sampler.setParam("pan_1", 0.5);
                    sampler.setParam("pan_2", 0.5);
                    sampler.setParam("pan_3", 0.5);
                    sampler.setParam("pan_4", 0.5);
                    sampler.setParam("gain_0", 1);
                    sampler.setParam("gain_1", 1);
                    sampler.setParam("gain_2", 1);    
                    sampler.setParam("gain_3", 1);    
                    sampler.setParam("gain_4", 1);  

                    sampler.mapped = ["rate_0", "rate_1", "rate_2", "rate_3", "rate_4"];


                    instruments.playPause();
                    instruments.setTempo(tempo);
                    sampler.setSequence(myDrumSequence, 4);

                    //Sequence and loop set at 4 ticks per beat (1/16ths)
                    backingMidSynth.setSequence(midSynthSeq, 4);
                    bassSynth.setSequence(bassSynthSeq, 4);
                    backingMidSynth.setLoop(16,4);
                    bassSynth.setLoop(16,4);
                    sampler.setLoop(16,4);
                    instruments.playPause();
					isLoaded = true;
                    instruments.setOnTick((playHeads)=> {
                        //The current playhead of the third instrument added
                        if(playHeads[2] % 3 == 2) {
                            metro+=0.5;
                        }
                        //double speed
//                         if(playHeads[2] % 3 == 2) {
//                             doubleMetro++;
//                         }
                        if(playHeads[2] % 16 == 4) {
                            sequenceTrigger = true;
                            eventFixer++;
                        } 
                    });
                }).catch((err)=> {
                    //console.log("error", err);
                });
            };
            //start the step sequencer
//             document.addEventListener('keydown', (event) => {
//                 if (event.key && soundUP == false){
//                     playSomething();
//                     //enemySynth.unmute();
//                     //backingMidSynth.unmute();
//                     //bassSynth.unmute();
//                     //sampler.unmute();
//                     instruments.playPause();
//                     soundUP = true; 
//                 }
//             });

            setInterval(run, 50);
            function run() {
                if (soundUP) {
                    movePlayheads();
                    stepSequencer(player);
                  if(isLoaded == true){
                   updateSounds(); 
                  }
                    
                    sequenceTracker(myDrumSequence);
                    updatePlatforms();
                    destroyer();

                }
                if(hasEnded == true){
                    end();
                }
                if(canStart == true ){
                    star.setAttribute('color', 'white');
                    player.setAttribute('position', {x:0, y: 2, z:8});
                    scene.setAttribute('background', {color: 'white'});
                    killplane.setAttribute('color', 'red');
                    for(let i = 0; i < 16; i++){
                        kicks[i] = false;
                        snares[i]=false;
                        hihats[i]=false;
                        bells[i]=false;
                    }
                    //startup();
                    //scene.appendChild(platformsEntity);
                    //playerSteps = [];
                    //collectableCount = 0;
                    //collectablesFound = 0;
                    //collectablePicked = false;
                    //instruments.setTempo(172);
                    //sampler.setParams([["gain_0", 1],["gain_1", 1],["gain_2", 1],["gain_3", 1] ]);
                    //bassSynth.setParam('gain', 0);
                    //backingMidSynth.setParam('gain', 1);
                    //backingMidSynth.setSequence(midSynthSeq, 2);
                    //bassSynth.setSequence(bassSynthSeq2, 4);
                    //instruments.rewind;
                    //backingMidSynth.setLoop(16,4);
                    //bassSynth.setLoop(64,4);
                    //sampler.setLoop(16,4);
                    //sampler.unmute;
                    //backingMidSynth.unmute;
                    //bassSynth.unmute;
                }
            }  
        </script>

    </body>
</html>
